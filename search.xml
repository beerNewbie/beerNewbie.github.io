<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>快速排序</title>
      <link href="/2019/04/22/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/04/22/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="快速排序：基于分治思想-O-nlogn"><a href="#快速排序：基于分治思想-O-nlogn" class="headerlink" title="快速排序：基于分治思想 O(nlogn)"></a>快速排序：基于分治思想 O(nlogn)</h3><ul><li style="list-style: none"><input type="checkbox"> <strong>算法思路</strong>： 从待排序数组中任意选取一个元素[l…r],称为分区点，每当发现比基准值小的元素就放在基准值左边，大的放右边。每遍历一次基准值在最终位置。</li><li><p>[ ] <strong>原地排序：</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//核心算法</span><br><span class="line">    int v = array[l];//基准值</span><br><span class="line">    int j = l;//比基准值小的范围[l+1,j]</span><br><span class="line">    int i = l+1;//比基准值大的范围[j+1,i-1],i是当前索引</span><br><span class="line">    for (;i &lt;= r; i++) &#123;</span><br><span class="line">        if (array[i] &lt; v) &#123;</span><br><span class="line">            swap(array,j+1,i);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(array,l,j);</span><br><span class="line">    return j;</span><br></pre></td></tr></table></figure></li><li><p>[ ] <strong>问题</strong>：当待排序的集合近乎有序时，若选取的基准恰好为最大值，此时分层退化为O(n)，时间复杂度退化为O(n^2)——最坏情况</p></li><li>最好情况：每次区分点的选择恰好在中间位置，时间复杂度为O(nlogn)</li><li>空间复杂度：O(1)，原地排序算法</li><li>稳定性：不稳定算法，<a href>若基准值为最后一个元素,5 4 3 2 6 1 5</a></li><li><p>如何在O(n)时间内找到一个无序数组的第K大元素?</p></li><li><p>[ ] <strong>快排优化：</strong> </p></li></ul><ol><li>当待排序的集合近乎有序时，由于默认选择的第一个元素为基准，会导致基准值划分的两个子数组严重不均衡，此时分层下来的结果近乎于n层，此时快排退化为复杂度为O(n^2)排序算法</li></ol><ul><li style="list-style: none"><input type="checkbox" checked> <strong>解决</strong>：随机选取一个元素作为基准值，来降低每次都选到最小或最大值的概率<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int randomIndex = (int)(Math.random() * (r-l+1) + l);</span><br><span class="line">swap(array,l,randomIndex);</span><br><span class="line">int v = array[l];//基准值</span><br><span class="line">int j = l;//比基准值小的范围[l+1,j]</span><br><span class="line">int i = l+1;//比基准值大的范围[j+1,i-1],i是当前索引</span><br><span class="line">for (;i &lt;= r; i++) &#123;</span><br><span class="line">    if (array[i] &lt; v) &#123;</span><br><span class="line">        swap(array,j+1,i);</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">swap(array,l,j);</span><br><span class="line">return j;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>当待排序数组含有大量重复元素时由于与基准值相等的元素个数过多，导致数组长度不均衡，此时分层下来的结果近乎n层，快排退化为O(n^2)</li></ol><ul><li><p>[x] <strong>二路快排</strong>：将大于和小于v的元素放在数组的两端,i索引不断向后扫描，当i的元素小于v时，i++;j索引不断向前扫描，当j的元素大于v时，j–;当i碰到一个&gt;=v的元素以及j碰到一个&lt;=v的元素，交换i与j的元素,i++,j–</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//核心算法</span><br><span class="line">        int randomIndex = (int)(Math.random() * (r-l+1) + l);</span><br><span class="line">        swap(array,l,randomIndex);</span><br><span class="line">        int v = array[l];</span><br><span class="line">        int i = l + 1;</span><br><span class="line">        int j = r;</span><br><span class="line">        while(true) &#123;</span><br><span class="line">            while(i &lt;= r &amp;&amp; array[i] &lt; v) i++;//注意：不仅要判断值的大小，还要判断i,j下标是否越界</span><br><span class="line">            while(j &gt;= l + 1 &amp;&amp; array[j] &gt; v) j--;</span><br><span class="line">            if (i &gt; j) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(array,i,j);</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">       swap(array,l,j);</span><br><span class="line">        return j;</span><br></pre></td></tr></table></figure></li><li><p>[x] <strong>三路快排</strong>：</p></li><li style="list-style: none"><input type="checkbox" checked> <strong>归并排序优化</strong>：</li><li>当元素个数比较小的时候，直接调用直接插入排序</li><li>当左边数组最大元素都小于右边数组最小元素，说明整个数组有序</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DataStructures </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 三大类</title>
      <link href="/2019/04/22/Java-%E4%B8%89%E5%A4%A7%E7%B1%BB/"/>
      <url>/2019/04/22/Java-%E4%B8%89%E5%A4%A7%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><blockquote><p>注：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Test &#123;</span><br><span class="line">    public  int data = 10;//堆</span><br><span class="line">    public static int data2 = 20;//方法区</span><br><span class="line">    public static final int data3 = 30;//方法区</span><br><span class="line">    public final int data4 = 40;//堆</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;helloworld&quot;;//直接赋值放在常量池</span><br><span class="line">Strring str2 = &quot;hello&quot; + &quot;world&quot;;//常量池</span><br><span class="line">System.out.print(str == str2);//true</span><br><span class="line">Strring str3 = &quot;hello&quot;;</span><br><span class="line">String str4 = str3 + &quot;word&quot;;//str3是一个变量</span><br><span class="line">System.out.prinntln(str == str4);//false</span><br><span class="line"></span><br><span class="line">String str5 = new String(&quot;terry&quot;).intern();//intern()手动入池方法，如果常量池已经有，则直接返回常量池中的地址，下式仍然相等</span><br><span class="line">String str6 = &quot;terry&quot;;</span><br><span class="line">System.out.println(str5 == str6);//true</span><br></pre></td></tr></table></figure><p>如何判断常量池是否存在字符常量</p><ul><li style="list-style: none"><input type="checkbox" checked> <strong>String StringBuffer 和StringBuilder的区别和 联系：</strong></li><li>StringBuffer –&gt; synchronized，StringBuffer多线程情况下使用，sychronized线程安全关键字，StringBuilder 、String都没有，线程不安全</li><li>StringBuffer、StringBuilder的append（）方法不会产生垃圾空间，追加后，地址不会改变；</li><li>String的拼接底层会优化为StringBuilder append进行拼接，结果会调用StringBuilder的toString（）,但在循环中拼接时，优先使用StringBuilder；</li><li style="list-style: none"><input type="checkbox"> StringIndexOutOfBoundsException </li><li style="list-style: none"><input type="checkbox"> Character.isDigit() 判断一个字符是否为数字</li><li style="list-style: none"><input type="checkbox"> 基类可以引用派生类对象（类，接口）<h3 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h3><h5 id="装箱（装包）：把一个简单类型包装为一个对象"><a href="#装箱（装包）：把一个简单类型包装为一个对象" class="headerlink" title="装箱（装包）：把一个简单类型包装为一个对象"></a>装箱（装包）：把一个简单类型包装为一个对象</h5></li><li style="list-style: none"><input type="checkbox"> <a href>Integer a = 10;//自动装箱:Integer.valueOf()</a></li><li style="list-style: none"><input type="checkbox"> <a href>Integer b = new Integer(20;//显示装箱（没有调用valueOf）)</a><h5 id="拆箱：把包装类拆分为简单类型"><a href="#拆箱：把包装类拆分为简单类型" class="headerlink" title="拆箱：把包装类拆分为简单类型"></a>拆箱：把包装类拆分为简单类型</h5></li><li style="list-style: none"><input type="checkbox"> <a href>int i = a;//自动拆箱：Integer.intValue()</a></li><li style="list-style: none"><input type="checkbox"> <a href>double d = a.doubleValue();</a><blockquote><p><strong>valueOf判断实例：(具体原因看valueOf源代码)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer a = 100;</span><br><span class="line">Integer b = 100;</span><br><span class="line">System.out.println(a == b);//true</span><br><span class="line">Integer a = 200;</span><br><span class="line">Integer b = 200;</span><br><span class="line">System.out.println(a == b);//false</span><br><span class="line">//原因valueOf在-128~127之间直接引用，否则new一个新对象；</span><br></pre></td></tr></table></figure></blockquote></li></ul><h3 id="单例："><a href="#单例：" class="headerlink" title="单例："></a>单例：</h3><ul><li style="list-style: none"><input type="checkbox"> 请使用吧静态内部类实现一个单例模式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class MySingleton &#123;</span><br><span class="line">    private MySingleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    private static class Single &#123;</span><br><span class="line">        public static MySingleton mySingleton = new MySingleton();</span><br><span class="line">    &#125;</span><br><span class="line">    public static MySingleton getInstance() &#123;</span><br><span class="line">        return Single.mySingleton;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaSE基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何不翻墙访问谷歌</title>
      <link href="/2019/04/20/%E5%A6%82%E4%BD%95%E4%B8%8D%E7%BF%BB%E5%A2%99%E8%AE%BF%E9%97%AE%E8%B0%B7%E6%AD%8C/"/>
      <url>/2019/04/20/%E5%A6%82%E4%BD%95%E4%B8%8D%E7%BF%BB%E5%A2%99%E8%AE%BF%E9%97%AE%E8%B0%B7%E6%AD%8C/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp; 我们都知道谷歌浏览器被全球公认为全球最大的搜索引擎公司，而且不像百度，360等前几条全是广告。因此很方便我们进行资料查询。而现在是不允许访问谷歌的，进行翻墙的话，要么网速不稳定，要么得花钱。<strong>那如何访问呢？</strong></p><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><ul><li>首先下载<strong>360极速浏览器</strong>，它基于<a href="https://baike.baidu.com/item/Chromium/529755" target="_blank" rel="noopener">Chromium</a>开源项目，具有闪电般的浏览速度、完备的安全特性及海量丰富的实用工具扩展。以前其自带谷歌访问助手，现在在插件中心收不到了。</li><li>下载Google访问助手，<a href="https://pan.baidu.com/s/1DXSmRyj1WJO6UW7xfTtSaQ" target="_blank" rel="noopener">点这里</a>,提取码<strong>e50z </strong>；</li><li>下载好后，打开360急速浏览器，再直接运行插件即可。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客</title>
      <link href="/2019/04/19/%E4%B8%8A%E4%BC%A0/"/>
      <url>/2019/04/19/%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="基于Hexo搭建个人博客"><a href="#基于Hexo搭建个人博客" class="headerlink" title="基于Hexo搭建个人博客"></a>基于Hexo搭建个人博客</h3><h4 id="创建原因："><a href="#创建原因：" class="headerlink" title="创建原因："></a>创建原因：</h4><p>&nbsp; &nbsp; 以前我写的博客都上传在<a href="https://github.com/beerNewbie" target="_blank" rel="noopener">github</a>上，但是每次想查询、复习的时候都不是十分方便。至于CSDN就是广告让人受不了。并且看见 别人那简洁清新的博客，心里很是痒痒。便自己动手搭建一个。</p><h4 id="历程"><a href="#历程" class="headerlink" title="历程"></a>历程</h4><p>&nbsp; &nbsp; 通过网上的一些视频资料，搭建起来不是很难。但要配置出自己喜欢的主题还是很费精力的，我前前后后下了几个主题，要么修改起来太过复杂，要么界面不好看。后来还是老老实实的选择很适合新手的<a href="https://http://theme-next.iissnan.com/" target="_blank" rel="noopener">hexo-theme-next</a>这款主题。很简洁清新。</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> others </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
