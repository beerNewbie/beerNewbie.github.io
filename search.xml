<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>快排</title>
      <link href="/2019/04/21/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/04/21/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="快速排序：基于分治思想-O-nlogn"><a href="#快速排序：基于分治思想-O-nlogn" class="headerlink" title="快速排序：基于分治思想 O(nlogn)"></a>快速排序：基于分治思想 O(nlogn)</h3><ul><li><p>算法思路： 从待排序数组中任意选取一个元素[l…r],称为分区点，每当发现比基准值小的元素就放在基准值左边，大的放右边。每遍历一次基准值在最终位置。</p></li><li><p>原地排序：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//核心算法</span><br><span class="line">        int v = array[l];//基准值</span><br><span class="line">        int j = l;//比基准值小的范围[l+1,j]</span><br><span class="line">        int i = l+1;//比基准值大的范围[j+1,i-1],i是当前索引</span><br><span class="line">        for (;i &lt;= r; i++) &#123;</span><br><span class="line">            if (array[i] &lt; v) &#123;</span><br><span class="line">                swap(array,j+1,i);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(array,l,j);</span><br><span class="line">        return j;</span><br></pre></td></tr></table></figure><ul><li>问题：当待排序的集合近乎有序时，若选取的基准恰好为最大值，此时分层退化为O(n)，时间复杂度退化为O(n^2)——最坏情况</li><li>最好情况：每次区分点的选择恰好在中间位置，时间复杂度为O(nlogn)</li><li>空间复杂度：O(1)，原地排序算法</li><li>稳定性：不稳定算法，<a href>若基准值为最后一个元素,5 4 3 2 6 1 5</a></li><li>如何在O(n)时间内找到一个无序数组的第K大元素?</li><li>快排优化：</li></ul><ol><li>当待排序的集合近乎有序时，由于默认选择的第一个元素为基准，会导致基准值划分的两个子数组严重不均衡，此时分层下来的结果近乎于n层，此时快排退化为复杂度为O(n^2)排序算法</li></ol><ul><li>解决：随机选取一个元素作为基准值，来降低每次都选到最小或最大值的概率<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int randomIndex = (int)(Math.random() * (r-l+1) + l);</span><br><span class="line">swap(array,l,randomIndex);</span><br><span class="line">int v = array[l];//基准值</span><br><span class="line">int j = l;//比基准值小的范围[l+1,j]</span><br><span class="line">int i = l+1;//比基准值大的范围[j+1,i-1],i是当前索引</span><br><span class="line">for (;i &lt;= r; i++) &#123;</span><br><span class="line">    if (array[i] &lt; v) &#123;</span><br><span class="line">        swap(array,j+1,i);</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">swap(array,l,j);</span><br><span class="line">return j;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>当待排序数组含有大量重复元素时由于与基准值相等的元素个数过多，导致数组长度不均衡，此时分层下来的结果近乎n层，快排退化为O(n^2)</li></ol><ul><li><p>二路快排：将大于和小于v的元素放在数组的两端,i索引不断向后扫描，当i的元素小于v时，i++;j索引不断向前扫描，当j的元素大于v时，j–;当i碰到一个&gt;=v的元素以及j碰到一个&lt;=v的元素，交换i与j的元素,i++,j–</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//核心算法</span><br><span class="line">        int randomIndex = (int)(Math.random() * (r-l+1) + l);</span><br><span class="line">        swap(array,l,randomIndex);</span><br><span class="line">        int v = array[l];</span><br><span class="line">        int i = l + 1;</span><br><span class="line">        int j = r;</span><br><span class="line">        while(true) &#123;</span><br><span class="line">            while(i &lt;= r &amp;&amp; array[i] &lt; v) i++;//注意：不仅要判断值的大小，还要判断i,j下标是否越界</span><br><span class="line">            while(j &gt;= l + 1 &amp;&amp; array[j] &gt; v) j--;</span><br><span class="line">            if (i &gt; j) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(array,i,j);</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">       swap(array,l,j);</span><br><span class="line">        return j;</span><br></pre></td></tr></table></figure></li><li><p>三路快排：</p></li><li>归并排序优化：</li><li>当元素个数比较小的时候，直接调用直接插入排序</li><li>当左边数组最大元素都小于右边数组最小元素，说明整个数组有序</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/04/20/%E4%B8%8A%E4%BC%A0/"/>
      <url>/2019/04/20/%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第一篇博客"><a href="#第一篇博客" class="headerlink" title="第一篇博客"></a>第一篇博客</h1><h3 id="基于Hexo创建个人博客"><a href="#基于Hexo创建个人博客" class="headerlink" title="基于Hexo创建个人博客"></a>基于Hexo创建个人博客</h3><h4 id="历经各种波折，模型初步呈现"><a href="#历经各种波折，模型初步呈现" class="headerlink" title="历经各种波折，模型初步呈现"></a>历经各种波折，模型初步呈现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//接触Java的第一篇代码</span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void  main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;Hello word&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
