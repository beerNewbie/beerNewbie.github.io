<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java集合框架</title>
      <link href="/2019/04/24/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
      <url>/2019/04/24/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="Java类集（数据结构-多线程）-java-util"><a href="#Java类集（数据结构-多线程）-java-util" class="headerlink" title="Java类集（数据结构-多线程）-java.util.*"></a>Java类集（数据结构-多线程）-java.util.*</h3><p><a href>动态数组(当元素个数达到最大值时，动态增加容量)</a></p><h4 id="1-Java类集产生-JDK1-2"><a href="#1-Java类集产生-JDK1-2" class="headerlink" title="1.Java类集产生-JDK1.2"></a>1.Java类集产生-JDK1.2</h4><p><strong>动态数组：解决定长问题</strong></p><h5 id="1-2-Collection接口-单个对象保存的最顶层父接口"><a href="#1-2-Collection接口-单个对象保存的最顶层父接口" class="headerlink" title="1.2 Collection接口-单个对象保存的最顶层父接口"></a>1.2 Collection接口-<a href>单个对象</a>保存的最顶层父接口</h5><ul><li style="list-style: none"><input type="checkbox" checked> Collection接口及其子接口，在每次进行数据操作时只能对单个对象进行处理。</li><li>public interface Collection<e> extends Iterable<e></e></e></li><li style="list-style: none"><input type="checkbox" checked> Iterable<e>:迭代器接口（就是为了遍历集合）</e></li><li style="list-style: none"><input type="checkbox" checked> iterator<t> iterator();(取得集合的迭代器，JDK1.5之前直接写在Collection接口中)</t></li><li style="list-style: none"><input type="checkbox" checked> Collection接口中提供的核心方法：</li><li><a href>add(T t):向类集中添加元素</a></li><li><a href>iterator():取得类集的迭代器</a></li><li>Collection接口只定义了存储数据的标准，但无法区分存储类型。因此在实际中往往使用两个子接口List（允许数据重复）、Set（不允许数据重复）。一般不直接使用Collection接口。<h4 id="2-List接口"><a href="#2-List接口" class="headerlink" title="2.List接口"></a>2.List接口</h4>在进行单个集合处理时，优先考虑List接口</li><li style="list-style: none"><input type="checkbox" checked> 在List接口中拓展了两个重要方法（List接口独有）</li><li>public E get(int index) :根据索引下标取得数据；</li><li>public E set(int index,E element) :根据索引下标更新数据，返回修改前数据</li><li style="list-style: none"><input type="checkbox" checked> List接口有三个重要子类<a href>ArrayList(90%)、Vector、LinkedList</a>,这三个子类在使用上没有任何区别</li><li style="list-style: none"><input type="checkbox" checked> List接口要保存自定义类的对象，该类必须覆写equals()来使用contains()、remove()等方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//覆写equals()方法</span><br><span class="line">@Override</span><br><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">    if (obj == this) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;else if (obj == null) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;else if (!(obj instanceof Person)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //向下转型还原为Person对象</span><br><span class="line">    Person person = (Person) obj;</span><br><span class="line">    retrun this.age.equals(per.age) &amp;&amp; this.name.equals(per.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="Important-ArrayList、Vector、LinkedList的区别："><a href="#Important-ArrayList、Vector、LinkedList的区别：" class="headerlink" title="[Important]:==ArrayList、Vector、LinkedList的区别：=="></a>[Important]:==ArrayList、Vector、LinkedList的区别：==</h5><ul><li style="list-style: none"><input type="checkbox"> ArrayList、LinkedList的区别： </li><li>1、出现版本：ArrayList –&gt;JDK1.2 而Vector–&gt;JDK1.0(出现在List、Collection接口之前)</li><li>2、初始化策略区别：Vector在无参构造执行后将对象数组大小初始化为10；ArrayList采用懒加载策略，在构造方法阶段并不初始化对象数组，在第一次添加元素时才初始化对象数组大小为10</li><li>3、扩容策略：ArrayList扩容时，新数组变为原数组的1.5倍，Vector扩容时，新数组大小变为原数组的2倍；</li><li>4、线程安全性：ArrayList采用异步处理，线程不安全，效率较高；Vector采用方法上加锁(synchronized关键字(同步的，代表这个方法加锁))，线程安全，效率较低。（即便使用线程安全的List，也不用Vector）</li><li>5、遍历：Vector支持较老的Enumeration，ArrayList不支持，ArrayList支持Iterator、ListIterator、foreach；Vector支持Iterator、ListIterator、foreach、<br>Enumeration。</li><li style="list-style: none"><input type="checkbox"> ArrayList、Vector的共同点：底层均使用数组实现</li><li style="list-style: none"><input type="checkbox" checked> ArrayList、LinkedList区别：LinkedList底层采用双向链表实现，ArrayList底层采用数组实现<h3 id="3-Set接口"><a href="#3-Set接口" class="headerlink" title="3.Set接口"></a>3.Set接口</h3></li><li style="list-style: none"><input type="checkbox" checked> <strong>不允许数据重复（Set接口就是Value值相同的Map集合，先有Map才有Set），Set接口没有扩充方法</strong><h4 id="Set接口常用子类："><a href="#Set接口常用子类：" class="headerlink" title="Set接口常用子类："></a>Set接口常用子类：</h4><h5 id="HashSet（无序存储）-HashMap："><a href="#HashSet（无序存储）-HashMap：" class="headerlink" title="HashSet（无序存储）-HashMap："></a>HashSet（无序存储）-HashMap：</h5></li><li style="list-style: none"><input type="checkbox"> 1、底层使用 哈希表+红黑树</li><li style="list-style: none"><input type="checkbox"> 2、允许存放null，无序存储<h5 id="TreeSet（有序存储）-TreeMap：Comparable、Compartor"><a href="#TreeSet（有序存储）-TreeMap：Comparable、Compartor" class="headerlink" title="TreeSet（有序存储）- TreeMap：Comparable、Compartor"></a>TreeSet（有序存储）- TreeMap：Comparable、Compartor</h5></li><li style="list-style: none"><input type="checkbox"> 1、底层使用红黑树</li><li style="list-style: none"><input type="checkbox"> 2、不允许出现null，有序存储</li><li style="list-style: none"><input type="checkbox"> 3、自定义类要想保存到TreeSet中，要么实现Comparable接口，要么向TreeSet传入比较器（Comparator接口）<h6 id="Comparable与Commparator的区别："><a href="#Comparable与Commparator的区别：" class="headerlink" title="Comparable与Commparator的区别："></a>Comparable与Commparator的区别：</h6></li><li style="list-style: none"><input type="checkbox"> 在Java中，若想实现自定义类的比较，提供了以下两个接口：<blockquote><p><strong>java.lang.Comparable接口（内部比较器）-排序接口</strong>：</p></blockquote></li><li>若一个类实现了Comparable接口，就意味着该类支持排序。存放该类的Collection或数组，可以直接通过Collections.sort()或Array.sort()进行排序。</li><li>实现了Comparable接口的类可以直接放在TreeSet或TreeMap中</li><li><a href>public int compareTo(); 返回值三种情况：</a><strong>返回正数</strong>：表示当前对象大于目标对象；<strong>返回0</strong>：表示当前对象等于目标对象；<strong>返回负数</strong> ：表示当前对象小于目标对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//覆写compareTo,自定义Person类如何比较大小（按年龄）</span><br><span class="line">@Override</span><br><span class="line">public int compareTo(Person o) &#123;</span><br><span class="line">    if (this.age &gt; o.age) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;else if (this.age &lt; o.age) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        return this.name.compareTo(o.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>Comparator(外部排序接口):</strong></p><ul><li>若要控制某个自定义类的顺序，而该类本身不支持排序（该类本身没有实现Comparable接口）。我们可以建立一个该类的“比较器”来进行排序。比较器实现Comparator接口即可。</li><li>“比较器”：实现了Comparator接口的类作为比较器，通过该比较器来进行类的排序。</li><li><a href>public int compare(T o1, T o2);返回值与compareTo返回值完全一样：</a>返回正数：o1 &gt; o2;返回0：o1 = o2;返回负数：o1 &lt; o2;</li><li>实现了Comparator接口进行第三方排序- <strong>策略模式</strong> ，此方法更加灵活，可以轻松改变策略进行第三方的排序算法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//Person类的比较器</span><br><span class="line">class AscAgeComparator implements Comparator&lt;Person&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Person o1,Person o2) &#123;</span><br><span class="line">        reeturn o1.getAge() - o2.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">    //只重写了compare方法，而equals方法在Object类中就已经写了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h5 id="Comparable接口与Comparator接口的关系："><a href="#Comparable接口与Comparator接口的关系：" class="headerlink" title="Comparable接口与Comparator接口的关系："></a>Comparable接口与Comparator接口的关系：</h5><ul><li style="list-style: none"><input type="checkbox" checked> Comparable 是排序接口，若一个类实现了Comparable接口，意味着该类支持排序，是一个内部比较器（自己和别人去比）</li><li style="list-style: none"><input type="checkbox" checked> Comparator接口是比较器接口，类本身不支持排序，专门有若干个第三方的比较器（实现了Comparator接口）来进行排序比较，是一个外部比较器（策略模式）<h5 id="重复元素的判断："><a href="#重复元素的判断：" class="headerlink" title="重复元素的判断："></a>重复元素的判断：</h5></li><li style="list-style: none"><input type="checkbox" checked> TreeSet与TreeMap依靠Comparator或Comparable接口来区分重复元素。<h5 id="自定义类要想保存在TreeMap或TreeSet中："><a href="#自定义类要想保存在TreeMap或TreeSet中：" class="headerlink" title="自定义类要想保存在TreeMap或TreeSet中："></a>自定义类要想保存在TreeMap或TreeSet中：</h5></li><li style="list-style: none"><input type="checkbox"> 要么该类直接实现Comparable接口，覆写compareTo方法</li><li style="list-style: none"><input type="checkbox"> 要么实现一个比较器，传入TreeSet或TreeMap来进行外部比较<h5 id="而HashSet与HashMap并不依赖比较接口。此时要想区分自定义元素是否重复，需要同时覆写equals与hashCode方法"><a href="#而HashSet与HashMap并不依赖比较接口。此时要想区分自定义元素是否重复，需要同时覆写equals与hashCode方法" class="headerlink" title="而HashSet与HashMap并不依赖比较接口。此时要想区分自定义元素是否重复，需要同时覆写equals与hashCode方法"></a>而HashSet与HashMap并不依赖比较接口。此时要想区分自定义元素是否重复，需要同时覆写equals与hashCode方法</h5></li><li style="list-style: none"><input type="checkbox"> 首先覆写equals()方法来判定元素内容是否相等。</li><li style="list-style: none"><input type="checkbox"> 覆写equals方法原则：</li><li>自反性：对于任何非空引用值想x, x.equals(x)都返回true</li><li>对称性：对于任何非空x,y,当且仅当x.equals(y)返回true，y.equals(x)也返回true</li><li>传递性：对于任何非空x,y,z,若x.equals(y)返回true，y.equals(z)返回true，一定有x.equals(z)返回true</li><li>一致性：对于任何非空的x,y,若想x与y的属性没有发生改变，则多次调用x.equals(y)始终返回true或false</li><li>非空性：对于任何的非空x，x.equals(null)一定返回false</li><li style="list-style: none"><input type="checkbox"> 先调用hashCode计算出hash码决定存放的数据桶，而后使用equals来比较元素是否相等，若相等，则不放置元素；若equals返回false。则在相同桶之后，使用链表将若干元素链起来。（先hashCode，若在一个数据桶再equals）</li><li><p>Object类提供的hashCode方法默认使用对象的地址进行hash</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//覆写hashCode ，把两个值做hash，而不是地址，hashCode保证属性值相同的元素一定在一个桶中，equals方法保证若是不一个东西就set</span><br><span class="line">public int hashCode() &#123;</span><br><span class="line">    return Objects.hash(age,name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>[ ] <strong>若两个equals方法返回true，他们的hashCode必然保证相等（相同值的hash码一定相等）。但两对象的hashCode相等equals不一定相等，当且仅当equals与hashCode均返回true，才认为两个对象真的相等</strong></p></li><li style="list-style: none"><input type="checkbox"> 哈希表：优化查找次数<h3 id="4-集合输出-迭代器输出-Iterator接口"><a href="#4-集合输出-迭代器输出-Iterator接口" class="headerlink" title="4. 集合输出(迭代器输出)-Iterator接口"></a>4. 集合输出(迭代器输出)-Iterator接口</h3></li><li style="list-style: none"><input type="checkbox"> 迭代器：为了遍历集合而生。-迭代器模式<h4 id="Iterator接口的两个核心方法："><a href="#Iterator接口的两个核心方法：" class="headerlink" title="Iterator接口的两个核心方法："></a>Iterator接口的两个核心方法：</h4></li><li style="list-style: none"><input type="checkbox"> <a href>boolean hasNext(); 判断是否还有元素</a></li><li style="list-style: none"><input type="checkbox"> <a href>E next(); 取得下一个元素</a><h5 id="4-1迭代器输出Iterator-只能从前向后输出"><a href="#4-1迭代器输出Iterator-只能从前向后输出" class="headerlink" title="4.1迭代器输出Iterator-只能从前向后输出"></a>4.1迭代器输出Iterator-只能从前向后输出</h5></li><li style="list-style: none"><input type="checkbox"> 调用Collection集合的子类Iterator方法取得内置迭代器，使用以下格式输出：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while (iterator.hasNext()) &#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="4-2-双向迭代接口ListIterator-List支持，Set不支持"><a href="#4-2-双向迭代接口ListIterator-List支持，Set不支持" class="headerlink" title="4.2 双向迭代接口ListIterator-List支持，Set不支持"></a>4.2 双向迭代接口ListIterator-List支持，Set不支持</h5><ul><li style="list-style: none"><input type="checkbox"> 除了hasNext与next方法外，还有：</li><li>hasPrevious():判断是否有上一个元素</li><li>previous：取得上一个元素</li><li style="list-style: none"><input type="checkbox"> 要想使用从后向前遍历输出，首先至少要从前向后遍历一次才可使用<h5 id="4-3-Enumeration（JDK1-0）枚举输出-Vector类支持"><a href="#4-3-Enumeration（JDK1-0）枚举输出-Vector类支持" class="headerlink" title="4.3 Enumeration（JDK1.0）枚举输出-Vector类支持"></a>4.3 Enumeration（JDK1.0）枚举输出-Vector类支持</h5></li><li style="list-style: none"><input type="checkbox"> hasMoreElements():判断是否有下一个元素</li><li style="list-style: none"><input type="checkbox"> nextElements():取得下一个元素<h5 id="4-4-for-each输出（所有子类都满足）"><a href="#4-4-for-each输出（所有子类都满足）" class="headerlink" title="4.4 for-each输出（所有子类都满足）"></a>4.4 for-each输出（所有子类都满足）</h5></li><li style="list-style: none"><input type="checkbox"> 能使用for-each输出的本质在于各个集合类都内置迭代器</li></ul><h5 id="fail-fast机制："><a href="#fail-fast机制：" class="headerlink" title="fail-fast机制："></a>fail-fast机制：</h5><ul><li><p>[ ] ConcurrentModificationExcetion发生在Collection集合使用迭代器遍历时，使用了集合类提供的修改集合内容方法报错。而如果使用Iterator迭代器的remove()不会出现此错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//出错机制：</span><br><span class="line">final void checkForComodification() &#123;</span><br><span class="line">    if (modCount != expectedModCount)</span><br><span class="line">        throw new ConcurrentModificationException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Collection 集合中的modCount表示当前集合的修改次数</p></li><li>expectModcount是迭代器中记录当前集合的修改次数，当取得集合迭代器时（即调用list.iterator()）,exceptedModCount = modCount，换言之，迭代器就是当前集合的一个副本。</li><li>快速失败策略保证了所有用户在进行迭代遍历集合时，拿到的数据一定是最新的数据。（避免“脏读产生”）</li><li><strong>fail-safe:</strong> 不产生ConCurrentModificationException异常，jar包下所有的线程安全集合（CopyOnWriteArrayList）</li><li><strong>总结：以后在迭代器遍历时，不要修改集合内容</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//eg：</span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Strring&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        Collections.addAll(list,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;);</span><br><span class="line">        //modCount = 6</span><br><span class="line">        Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">        //取得集合迭代器（取得当前集合的副本）</span><br><span class="line">        //expectedModCount = 6</span><br><span class="line">        while(iterator.hasNext()) &#123;</span><br><span class="line">            //调用checkForComodification检查副本中的exceptedModCount是否等于集合的modCount</span><br><span class="line">            String str = iterator.next();</span><br><span class="line">            if (strr.equals(&quot;B&quot;)) &#123;</span><br><span class="line">                //list.remove(&quot;B&quot;);//集合类提供的remove方法，报错：ConcurrentModeficationException;</span><br><span class="line">                iterator.remove(&quot;B&quot;);//正确</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-Map集合"><a href="#5-Map集合" class="headerlink" title="5.Map集合"></a>5.Map集合</h2><h5 id="Map接口是Java中保存二元偶对象（键值对）的最顶层接口"><a href="#Map接口是Java中保存二元偶对象（键值对）的最顶层接口" class="headerlink" title="Map接口是Java中保存二元偶对象（键值对）的最顶层接口"></a>Map接口是Java中保存二元偶对象（键值对）的最顶层接口</h5><p><a href>public interface Map&lt;K,V&gt; key值唯一，通过key值一定能唯一找到一个value值</a></p><h5 id="Map接口中的核心方法："><a href="#Map接口中的核心方法：" class="headerlink" title="Map接口中的核心方法："></a>Map接口中的核心方法：</h5><ul><li><strong>public V put(K key,V value):向Map中添加数据</strong></li><li><strong>public V get(K key) :根据指定的key值取得相应的value值，若没有key值则返回null</strong></li><li><a href>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() : 将Map集合变为Set集合</a></li><li><strong>public Set<k> keySet()</k></strong> : 返回所有key值，<strong>key不能重复</strong>。</li><li><strong>public Collection<v> values()</v></strong> : 返回所有value值，<strong>value可以重复</strong>。<h4 id="Map接口有如下常用子类："><a href="#Map接口有如下常用子类：" class="headerlink" title="Map接口有如下常用子类："></a>Map接口有如下常用子类：</h4><a href>HashMap、TreeMap、HashTable、ConcurrentHashMap</a></li></ul><h4 id="HashMap与HashTable区别："><a href="#HashMap与HashTable区别：" class="headerlink" title="HashMap与HashTable区别："></a>HashMap与HashTable区别：</h4><ul><li style="list-style: none"><input type="checkbox"> HashMap-类比HashSet</li><li>1.允许key和value为null，且key值有且只有一个为null，value可以有任意多个为null</li><li>2.JDK1.2产生</li><li>3.异步处理效率高，线程不安全</li><li>4.底层：hash表+红黑树（JDK8）</li><li style="list-style: none"><input type="checkbox"> HashTable</li><li>1.key与value均不为null</li><li>2.JDK1.0产生</li><li>3.使用方法加锁，效率低，线程安全</li><li>4.底层hash表<h4 id="Map集合使用迭代器输出："><a href="#Map集合使用迭代器输出：" class="headerlink" title="Map集合使用迭代器输出："></a>Map集合使用迭代器输出：</h4></li><li style="list-style: none"><input type="checkbox"> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet():将Map集合转为Set集合<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class TestMapIterator &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        map.put(1, &quot;Java&quot;);</span><br><span class="line">        map.put(2, &quot;C++&quot;);</span><br><span class="line">        map.put(3, &quot;Python&quot;);</span><br><span class="line">        //Map——&gt;Set</span><br><span class="line">        Set&lt;Map.Entry&lt;Integer, String&gt;&gt; set = map.entrySet();</span><br><span class="line">        //取得Set接口迭代器</span><br><span class="line">        Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = set.iterator();</span><br><span class="line">        //迭代输出</span><br><span class="line">        while (iterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class="line">            System.out.println(entry.getKey() + &quot;=&quot; + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-栈和队列"><a href="#6-栈和队列" class="headerlink" title="6.栈和队列"></a>6.栈和队列</h3><h4 id="栈：先入后出-Vector"><a href="#栈：先入后出-Vector" class="headerlink" title="栈：先入后出-Vector"></a>栈：先入后出-Vector</h4><p> <strong>应用：</strong> 函数栈帧，浏览器网页的后腿，安卓Activity的后退 ，编译器撤销</p><ul><li>入栈：push</li><li>出栈：pop</li><li>返回栈顶元素但不出栈：peek()</li><li style="list-style: none"><input type="checkbox"> 自己实现一个html识别器：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void mian(String[] args) &#123;</span><br><span class="line">        Stack stack = new Stack();</span><br><span class="line">        stack.push(1);</span><br><span class="line">        stack.push(2);</span><br><span class="line">        stack.push(3);</span><br><span class="line">        System.out.println(stack.peek());//3</span><br><span class="line">        System.out.println(stack.pop());//3</span><br><span class="line">        System.out.println(stack.pop());//2</span><br><span class="line">        System.out.println(stack.pop());//1</span><br><span class="line">        System.out.println(stack.pop());//报错：EmptyStackException</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="队列FIFO：先入先出"><a href="#队列FIFO：先入先出" class="headerlink" title="队列FIFO：先入先出"></a>队列FIFO：先入先出</h4><p><strong>Queue接口-LinkedList</strong></p><p><a href>Queue<integer> queue = new LinkedList&lt;&gt;();</integer></a> </p><ul><li>入队列：add()</li><li>出队列：poll()</li><li>返回队列头元素，不出对：peek()</li><li>消息队列：kafka,RobitMQ<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">     public static void mian(String[] args) &#123;</span><br><span class="line">         Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">         queue.push(1);</span><br><span class="line">         queue.push(2);</span><br><span class="line">         queue.push(3);</span><br><span class="line">         System.out.println(stack.peek());//1</span><br><span class="line">         System.out.println(stack.poll());//1</span><br><span class="line">         System.out.println(stack.poll());//2</span><br><span class="line">         System.out.println(stack.poll());//3</span><br><span class="line">         System.out.println(stack.poll());//null</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="7-资源文件操作（Properties属性文件）"><a href="#7-资源文件操作（Properties属性文件）" class="headerlink" title="7.资源文件操作（Properties属性文件）"></a>7.资源文件操作（Properties属性文件）</h3><p>**资源文件内容都是k-v 格式，并且无论key、value都是String类型</p><h5 id="设置属性"><a href="#设置属性" class="headerlink" title="设置属性"></a>设置属性</h5><ul><li>setProperty(String key,String value) 返回Object<h5 id="取得属性"><a href="#取得属性" class="headerlink" title="取得属性"></a>取得属性</h5></li><li>getProperty(String key,String value) 返回String,若没有指定key，返回null</li><li>getProperty(String key,String defaultValue):若没有指定key值返回默认值<h5 id="将资源内容输入输出到目标终端"><a href="#将资源内容输入输出到目标终端" class="headerlink" title="将资源内容输入输出到目标终端"></a>将资源内容输入输出到目标终端</h5></li><li>输出到目标终端：store(OutputStream out,String comments);</li><li>从目标终端中读取数据：load(InputStream in);<h3 id="8-Collections工具类"><a href="#8-Collections工具类" class="headerlink" title="8.Collections工具类"></a>8.Collections工具类</h3><h5 id="1-将线程不安全的集合包装为线程安全的集合"><a href="#1-将线程不安全的集合包装为线程安全的集合" class="headerlink" title="1.将线程不安全的集合包装为线程安全的集合"></a>1.将线程不安全的集合包装为线程安全的集合</h5></li><li style="list-style: none"><input type="checkbox"> 在add、remove等方法修改上使用了同步代码块保证线程安全，效率较低。<strong>要使用线程安全集合，推荐使用juc包下的并发集合类（ConcurrentHashMap、CopyOnWriteArrayList）</strong></li><li style="list-style: none"><input type="checkbox"> 集合排序</li><li>Collection.sort(集合名称)</li><li style="list-style: none"><input type="checkbox"> 集合反转</li><li>Collections.reverse(集合名称)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class TestCollections01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        //向集合中一次添加多个元素</span><br><span class="line">        Collections.addAll(list, &quot;A&quot;, &quot;a&quot;, &quot;k&quot;, &quot;K&quot;, &quot;B&quot;, &quot;b&quot;);</span><br><span class="line">        //集合排序</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">        while (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.print(iterator.next() + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;\n&quot;);</span><br><span class="line">        iterator = list.iterator();</span><br><span class="line">        //集合反转</span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        while (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.print(iterator.next() + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 结果：</span><br><span class="line"> * A B K a b k</span><br><span class="line"> *</span><br><span class="line"> * k b a K B A</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></li></ul><h3 id="9-Stream数据流-Collection接口"><a href="#9-Stream数据流-Collection接口" class="headerlink" title="9.Stream数据流:Collection接口"></a>9.Stream数据流:Collection接口</h3><p><a href>核心方法:取得Stream流 Stream<e> stream()</e></a></p><h5 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h5><ul><li style="list-style: none"><input type="checkbox"> forEach:集合输出</li><li style="list-style: none"><input type="checkbox"> filter:数据过滤</li><li style="list-style: none"><input type="checkbox"> 取得最大最小值：max/min<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class TestStream01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Integer&gt; list = new LinkedList&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, 1, 2, 3, 4, 5, 6);</span><br><span class="line">        //list.forEach(System.out::print);</span><br><span class="line">        Stream&lt;Integer&gt; stream = list.stream();</span><br><span class="line">        //偶数个数</span><br><span class="line">   /*     System.out.println(&quot;count = &quot; +</span><br><span class="line">                stream.filter(e -&gt; e % 2 == 0).count());*/</span><br><span class="line">        //求集合中的最大最小值</span><br><span class="line">        System.out.println(stream.max(Integer::compareTo)</span><br><span class="line">                .get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="Map-Reduce模型"><a href="#Map-Reduce模型" class="headerlink" title="Map/Reduce模型"></a>Map/Reduce模型</h5><ul><li style="list-style: none"><input type="checkbox"> map():前期数据的处理</li><li style="list-style: none"><input type="checkbox"> reduce():数据处理后的收集<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class Goods &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer count;</span><br><span class="line">    private Double price;</span><br><span class="line"></span><br><span class="line">    public Goods(String name, Integer count, Double price) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.count = count;</span><br><span class="line">        this.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getCount() &#123;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCount(Integer count) &#123;</span><br><span class="line">        this.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Double getPrice() &#123;</span><br><span class="line">        return price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPrice(Double price) &#123;</span><br><span class="line">        this.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TestMapAndReduce &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Goods&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(new Goods(&quot;HUAWEI&quot;,500,6000.00));</span><br><span class="line">        list.add(new Goods(&quot;APPLE&quot;,200,7000.00));</span><br><span class="line">        list.add(new Goods(&quot;XIAOMI&quot;,600,3000.00));</span><br><span class="line">        list.add(new Goods(&quot;OPPO&quot;,300,3500.00));</span><br><span class="line">        Double costs = list.stream()</span><br><span class="line">                .map(obj -&gt; obj.getCount()*obj.getPrice())</span><br><span class="line">                .reduce((sum,x) -&gt; sum+x).get();</span><br><span class="line">        System.out.println(costs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//结果：7250000.0</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaSE基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/2019/04/22/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/04/22/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="快速排序：基于分治思想-O-nlogn"><a href="#快速排序：基于分治思想-O-nlogn" class="headerlink" title="快速排序：基于分治思想 O(nlogn)"></a>快速排序：基于分治思想 O(nlogn)</h3><ul><li style="list-style: none"><input type="checkbox"> <strong>算法思路</strong>： 从待排序数组中任意选取一个元素[l…r],称为分区点，每当发现比基准值小的元素就放在基准值左边，大的放右边。每遍历一次基准值在最终位置。</li><li><p>[ ] <strong>原地排序：</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//核心算法</span><br><span class="line">    int v = array[l];//基准值</span><br><span class="line">    int j = l;//比基准值小的范围[l+1,j]</span><br><span class="line">    int i = l+1;//比基准值大的范围[j+1,i-1],i是当前索引</span><br><span class="line">    for (;i &lt;= r; i++) &#123;</span><br><span class="line">        if (array[i] &lt; v) &#123;</span><br><span class="line">            swap(array,j+1,i);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(array,l,j);</span><br><span class="line">    return j;</span><br></pre></td></tr></table></figure></li><li><p>[ ] <strong>问题</strong>：当待排序的集合近乎有序时，若选取的基准恰好为最大值，此时分层退化为O(n)，时间复杂度退化为O(n^2)——最坏情况</p></li><li>最好情况：每次区分点的选择恰好在中间位置，时间复杂度为O(nlogn)</li><li>空间复杂度：O(1)，原地排序算法</li><li>稳定性：不稳定算法，<a href>若基准值为最后一个元素,5 4 3 2 6 1 5</a></li><li><p>如何在O(n)时间内找到一个无序数组的第K大元素?</p></li><li><p>[ ] <strong>快排优化：</strong> </p></li></ul><ol><li>当待排序的集合近乎有序时，由于默认选择的第一个元素为基准，会导致基准值划分的两个子数组严重不均衡，此时分层下来的结果近乎于n层，此时快排退化为复杂度为O(n^2)排序算法</li></ol><ul><li style="list-style: none"><input type="checkbox" checked> <strong>解决</strong>：随机选取一个元素作为基准值，来降低每次都选到最小或最大值的概率<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int randomIndex = (int)(Math.random() * (r-l+1) + l);</span><br><span class="line">swap(array,l,randomIndex);</span><br><span class="line">int v = array[l];//基准值</span><br><span class="line">int j = l;//比基准值小的范围[l+1,j]</span><br><span class="line">int i = l+1;//比基准值大的范围[j+1,i-1],i是当前索引</span><br><span class="line">for (;i &lt;= r; i++) &#123;</span><br><span class="line">    if (array[i] &lt; v) &#123;</span><br><span class="line">        swap(array,j+1,i);</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">swap(array,l,j);</span><br><span class="line">return j;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>当待排序数组含有大量重复元素时由于与基准值相等的元素个数过多，导致数组长度不均衡，此时分层下来的结果近乎n层，快排退化为O(n^2)</li></ol><ul><li><p>[x] <strong>二路快排</strong>：将大于和小于v的元素放在数组的两端,i索引不断向后扫描，当i的元素小于v时，i++;j索引不断向前扫描，当j的元素大于v时，j–;当i碰到一个&gt;=v的元素以及j碰到一个&lt;=v的元素，交换i与j的元素,i++,j–</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//核心算法</span><br><span class="line">        int randomIndex = (int)(Math.random() * (r-l+1) + l);</span><br><span class="line">        swap(array,l,randomIndex);</span><br><span class="line">        int v = array[l];</span><br><span class="line">        int i = l + 1;</span><br><span class="line">        int j = r;</span><br><span class="line">        while(true) &#123;</span><br><span class="line">            while(i &lt;= r &amp;&amp; array[i] &lt; v) i++;//注意：不仅要判断值的大小，还要判断i,j下标是否越界</span><br><span class="line">            while(j &gt;= l + 1 &amp;&amp; array[j] &gt; v) j--;</span><br><span class="line">            if (i &gt; j) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(array,i,j);</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">       swap(array,l,j);</span><br><span class="line">        return j;</span><br></pre></td></tr></table></figure></li><li><p>[x] <strong>三路快排</strong>：</p></li><li style="list-style: none"><input type="checkbox" checked> <strong>归并排序优化</strong>：</li><li>当元素个数比较小的时候，直接调用直接插入排序</li><li>当左边数组最大元素都小于右边数组最小元素，说明整个数组有序</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DataStructures </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 三大类</title>
      <link href="/2019/04/22/Java-%E4%B8%89%E5%A4%A7%E7%B1%BB/"/>
      <url>/2019/04/22/Java-%E4%B8%89%E5%A4%A7%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><blockquote><p>注：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Test &#123;</span><br><span class="line">    public  int data = 10;//堆</span><br><span class="line">    public static int data2 = 20;//方法区</span><br><span class="line">    public static final int data3 = 30;//方法区</span><br><span class="line">    public final int data4 = 40;//堆</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;helloworld&quot;;//直接赋值放在常量池</span><br><span class="line">Strring str2 = &quot;hello&quot; + &quot;world&quot;;//常量池</span><br><span class="line">System.out.print(str == str2);//true</span><br><span class="line">Strring str3 = &quot;hello&quot;;</span><br><span class="line">String str4 = str3 + &quot;word&quot;;//str3是一个变量</span><br><span class="line">System.out.prinntln(str == str4);//false</span><br><span class="line"></span><br><span class="line">String str5 = new String(&quot;terry&quot;).intern();//intern()手动入池方法，如果常量池已经有，则直接返回常量池中的地址，下式仍然相等</span><br><span class="line">String str6 = &quot;terry&quot;;</span><br><span class="line">System.out.println(str5 == str6);//true</span><br></pre></td></tr></table></figure><p>如何判断常量池是否存在字符常量</p><ul><li style="list-style: none"><input type="checkbox" checked> <strong>String StringBuffer 和StringBuilder的区别和 联系：</strong></li><li>StringBuffer –&gt; synchronized，StringBuffer多线程情况下使用，sychronized线程安全关键字，StringBuilder 、String都没有，线程不安全</li><li>StringBuffer、StringBuilder的append（）方法不会产生垃圾空间，追加后，地址不会改变；</li><li>String的拼接底层会优化为StringBuilder append进行拼接，结果会调用StringBuilder的toString（）,但在循环中拼接时，优先使用StringBuilder；</li><li style="list-style: none"><input type="checkbox"> StringIndexOutOfBoundsException </li><li style="list-style: none"><input type="checkbox"> Character.isDigit() 判断一个字符是否为数字</li><li style="list-style: none"><input type="checkbox"> 基类可以引用派生类对象（类，接口）<h3 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h3><h5 id="装箱（装包）：把一个简单类型包装为一个对象"><a href="#装箱（装包）：把一个简单类型包装为一个对象" class="headerlink" title="装箱（装包）：把一个简单类型包装为一个对象"></a>装箱（装包）：把一个简单类型包装为一个对象</h5></li><li style="list-style: none"><input type="checkbox"> <a href>Integer a = 10;//自动装箱:Integer.valueOf()</a></li><li style="list-style: none"><input type="checkbox"> <a href>Integer b = new Integer(20;//显示装箱（没有调用valueOf）)</a><h5 id="拆箱：把包装类拆分为简单类型"><a href="#拆箱：把包装类拆分为简单类型" class="headerlink" title="拆箱：把包装类拆分为简单类型"></a>拆箱：把包装类拆分为简单类型</h5></li><li style="list-style: none"><input type="checkbox"> <a href>int i = a;//自动拆箱：Integer.intValue()</a></li><li style="list-style: none"><input type="checkbox"> <a href>double d = a.doubleValue();</a><blockquote><p><strong>valueOf判断实例：(具体原因看valueOf源代码)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer a = 100;</span><br><span class="line">Integer b = 100;</span><br><span class="line">System.out.println(a == b);//true</span><br><span class="line">Integer a = 200;</span><br><span class="line">Integer b = 200;</span><br><span class="line">System.out.println(a == b);//false</span><br><span class="line">//原因valueOf在-128~127之间直接引用，否则new一个新对象；</span><br></pre></td></tr></table></figure></blockquote></li></ul><h3 id="单例："><a href="#单例：" class="headerlink" title="单例："></a>单例：</h3><ul><li style="list-style: none"><input type="checkbox"> 请使用吧静态内部类实现一个单例模式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class MySingleton &#123;</span><br><span class="line">    private MySingleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    private static class Single &#123;</span><br><span class="line">        public static MySingleton mySingleton = new MySingleton();</span><br><span class="line">    &#125;</span><br><span class="line">    public static MySingleton getInstance() &#123;</span><br><span class="line">        return Single.mySingleton;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaSE基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何不翻墙访问谷歌</title>
      <link href="/2019/04/20/%E5%A6%82%E4%BD%95%E4%B8%8D%E7%BF%BB%E5%A2%99%E8%AE%BF%E9%97%AE%E8%B0%B7%E6%AD%8C/"/>
      <url>/2019/04/20/%E5%A6%82%E4%BD%95%E4%B8%8D%E7%BF%BB%E5%A2%99%E8%AE%BF%E9%97%AE%E8%B0%B7%E6%AD%8C/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp; 我们都知道谷歌浏览器被全球公认为全球最大的搜索引擎公司，而且不像百度，360等前几条全是广告。因此很方便我们进行资料查询。而现在是不允许访问谷歌的，进行翻墙的话，要么网速不稳定，要么得花钱。<strong>那如何访问呢？</strong></p><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><ul><li>首先下载<strong>360极速浏览器</strong>，它基于<a href="https://baike.baidu.com/item/Chromium/529755" target="_blank" rel="noopener">Chromium</a>开源项目，具有闪电般的浏览速度、完备的安全特性及海量丰富的实用工具扩展。以前其自带谷歌访问助手，现在在插件中心收不到了。</li><li>下载Google访问助手，<a href="https://pan.baidu.com/s/1DXSmRyj1WJO6UW7xfTtSaQ" target="_blank" rel="noopener">点这里</a>,提取码<strong>e50z </strong>；</li><li>下载好后，打开360急速浏览器，再直接运行插件即可。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客</title>
      <link href="/2019/04/19/%E4%B8%8A%E4%BC%A0/"/>
      <url>/2019/04/19/%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="基于Hexo搭建个人博客"><a href="#基于Hexo搭建个人博客" class="headerlink" title="基于Hexo搭建个人博客"></a>基于Hexo搭建个人博客</h3><h4 id="创建原因："><a href="#创建原因：" class="headerlink" title="创建原因："></a>创建原因：</h4><p>&nbsp; &nbsp; 以前我写的博客都上传在<a href="https://github.com/beerNewbie" target="_blank" rel="noopener">github</a>上，但是每次想查询、复习的时候都不是十分方便。至于CSDN就是广告让人受不了。并且看见 别人那简洁清新的博客，心里很是痒痒。便自己动手搭建一个。</p><h4 id="历程"><a href="#历程" class="headerlink" title="历程"></a>历程</h4><p>&nbsp; &nbsp; 通过网上的一些视频资料，搭建起来不是很难。但要配置出自己喜欢的主题还是很费精力的，我前前后后下了几个主题，要么修改起来太过复杂，要么界面不好看。后来还是老老实实的选择很适合新手的<a href="https://http://theme-next.iissnan.com/" target="_blank" rel="noopener">hexo-theme-next</a>这款主题。很简洁清新。</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> others </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
