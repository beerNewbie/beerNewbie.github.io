<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HashMap源码分析</title>
      <link href="/2019/05/09/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2019/05/09/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h1><h2 id="Map接口：保存一元偶对象的最大父接口"><a href="#Map接口：保存一元偶对象的最大父接口" class="headerlink" title="Map接口：保存一元偶对象的最大父接口"></a>Map接口：保存一元偶对象的最大父接口</h2><h3 id="1-整体结构："><a href="#1-整体结构：" class="headerlink" title="1.整体结构："></a>1.整体结构：</h3><p><img src="https://img-blog.csdnimg.cn/20190509231929441.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JlZXJfeGlhb2NhaQ==,size_16,color_FFFFFF,t_70" alt="Map关系图"></p><ul><li style="list-style: none"><input type="checkbox"> <strong>在HashMap下有一个子类：LinkedHashMap，有序Map，序指的是元素的添加循序；而TreeMap有序Map，序指的是Comparator或Compareable</strong></li></ul><h3 id="2-常用方法：put-get"><a href="#2-常用方法：put-get" class="headerlink" title="2.常用方法：put,get"></a>2.常用方法：put,get</h3><h3 id="3-Map集合遍历"><a href="#3-Map集合遍历" class="headerlink" title="3.Map集合遍历"></a>3.Map集合遍历</h3><ul><li style="list-style: none"><input type="checkbox"> <strong>Set接口与Map接口的关系：Set接口就是穿了马甲的Map接口，本质上Set接口的子类都是使用Map来存储元素的，都是将元素存储到Map的key值里，value都是用共同点的 一个空Object对象。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先将Map集合变为Set集合，再迭代遍历</span></span><br><span class="line">Set&lt;Map.Entry&lt;Integer,String&gt;&gt; entrySet = map.entrySet();<span class="comment">//一个键值对看成一个Map.Entry对象</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;Integer,Sreing&gt;&gt; iterator = entrySet.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;Map.Entry&lt;Integer,String&gt;&gt; entry = iterator.next();</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">"="</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-常见问题解析"><a href="#4-常见问题解析" class="headerlink" title="4.常见问题解析"></a>4.常见问题解析</h3><h4 id="HashMap源码解析："><a href="#HashMap源码解析：" class="headerlink" title="HashMap源码解析："></a>HashMap源码解析：</h4><h5 id="1-成员变量：树化、数据结构（threshold译：阈值）"><a href="#1-成员变量：树化、数据结构（threshold译：阈值）" class="headerlink" title="1.成员变量：树化、数据结构（threshold译：阈值）"></a>1.成员变量：树化、数据结构（threshold译：阈值）</h5><ul><li style="list-style: none"><input type="checkbox"> DEFAULT_INITIAL-CAPACITY（初始化容量-桶的数量）：1 &lt;&lt; 4 (16)</li><li style="list-style: none"><input type="checkbox"> <strong>DEFAULT_LOAD_FACTOR(负载因子) ： 0.75</strong></li><li style="list-style: none"><input type="checkbox"> <strong>&gt;TREEIFY_THRESHOLD（树化阈值）：8</strong></li><li style="list-style: none"><input type="checkbox"> <strong>&gt;MIN_TREEIFY_CAPACITY（树化最少元素个数（如果整个哈希表中的元素个数没有大于64，只会扩容，不会树化））：64</strong></li><li style="list-style: none"><input type="checkbox"> <strong>UNTERRIFY_THRESHOLD（解树化，返回链表的阈值）：6</strong><ul><li><strong>在resize()过程中若发现桶下的红黑树节点&lt;=UNTREEIFY_THRESHOLD,会将红黑树解除树化还原为链表结构</strong></li></ul></li><li style="list-style: none"><input type="checkbox"> <strong>Node&lt;K,V&gt;[] table ：真正存储元素的哈希表</strong></li><li style="list-style: none"><input type="checkbox"> <strong>树化逻辑：当一个桶中链表元素大于等于8，并且哈希表中所有元素个数之和大于64，此时会将此桶中的链表结构转化为红黑树结构（可以防止链表过长导致查找太慢，从原来的O(n)优化为O(logn)，减少哈希碰撞），</strong> 若只是链表的个数大于8，而哈希表元素不超过64，此时只是简单的resize（扩容），并不会树化。</li></ul><h5 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2.构造函数"></a>2.构造函数</h5><ul><li><p>[ ] <strong>HashMap同样采用懒加载策略（并不会在对象产生时初始化哈希表）</strong></p></li><li><p>[ ] <strong>无参构造：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化负载因子</span></span><br><span class="line"><span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br></pre></td></tr></table></figure></li></ul><h5 id="3-put与get流程"><a href="#3-put与get流程" class="headerlink" title="3.put与get流程"></a>3.put与get流程</h5><h6 id="put方法："><a href="#put方法：" class="headerlink" title="put方法："></a>put方法：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);<span class="comment">//onlyIfAbsent 如果false允许其更改，evict 如果true默认其已经初始化好</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//手撕putVal源码</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n,i;</span><br><span class="line">    <span class="comment">//当前哈希表还未初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//若未初始化，resize()完成哈希表的初始化</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据key值hash后得到的桶下标（tab[]桶数组），判断桶中是否有元素</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//若为空，将要保存的节点放置在此桶的第一个元素</span></span><br><span class="line">        tab[i] = newNode(hash,key,value,<span class="keyword">null</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//节点处于同一个桶中头结点，key值与其相同就替换头结点,,</span></span><br><span class="line">        <span class="keyword">if</span>(p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))&#123;</span><br><span class="line">            e = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//hash(key)桶中元素不为空，判断此桶是否已经树化</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) &#123;</span><br><span class="line">            <span class="comment">//调用树化后的方法将新节点添加到红黑树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;p).putTreeVal)(<span class="keyword">this</span>,tab,hash,key,value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//桶中元素不为空并且还是链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>;; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//将新节点链到链表尾部</span></span><br><span class="line">                    p.next = newNOde(hash,key,value,<span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) &#123;</span><br><span class="line">                        treefyBin(tab,hash);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//普通替换value</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.value = value;</span><br><span class="line">            &#125;</span><br><span class="line">            aftereNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//判断添加元素之后整个的哈希表大小是否超过threshold</span></span><br><span class="line">    <span class="keyword">if</span>(++size &gt; threshold) &#123;</span><br><span class="line">        <span class="comment">//若超过阈值，调用resize()方法扩容</span></span><br><span class="line">        resize();</span><br><span class="line">    &#125;</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox"> <strong>1.若HashMap还未初始化，先进行哈希表的初始化操作（默认初始化为16个桶）</strong></li><li style="list-style: none"><input type="checkbox"> <strong>2.对传入的key值做hash，得出要存放该元素的桶编号：</strong></li><li><strong>(1). 若没有发生碰撞，即头结点为空，将该节点直接放到桶中作为头结点</strong></li><li><strong>(2). 若发生碰撞：</strong><ul><li><strong>a. 此桶中的链表已经树化，将节点构造为树节点后加入红黑树</strong></li><li><strong>b. 链表还未树化，将此节点作为链表的最后一个节点连入链表</strong></li></ul></li><li style="list-style: none"><input type="checkbox"> <strong>3.若hash表中存在key值相同的元素，替换最新的value值</strong></li><li style="list-style: none"><input type="checkbox"> <strong>4.若桶满了，调用resize()扩容hash表。</strong></li></ul><h6 id="get方法："><a href="#get方法：" class="headerlink" title="get方法："></a>get方法：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox"> <strong>当表还未初始化或者key值为null，return null</strong></li><li style="list-style: none"><input type="checkbox"> <strong>否则表示已经初始化并且key不为null：</strong></li></ul><ol><li><strong>key值刚好是桶的头结点，直接返回</strong></li><li><strong>遍历桶的其他节点：</strong><ul><li><strong>若已经树化，调用树的遍历方式找到指定key对应的Node返回</strong></li><li><strong>否则调用链表的遍历方式找到指定key对应的Node返回</strong></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Implements Map.get and related methods</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">       <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">           (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">               ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">               <span class="comment">//当前节点key是桶的第一个节点</span></span><br><span class="line">               <span class="keyword">return</span> first;</span><br><span class="line">           <span class="comment">//遍历桶的其他节点找到指定key返回其value </span></span><br><span class="line">           <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">//树的遍历</span></span><br><span class="line">               <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                   <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">               <span class="comment">//链表的遍历</span></span><br><span class="line">               <span class="keyword">do</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                       ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                       <span class="keyword">return</span> e;</span><br><span class="line">               &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//当表还未初始化或者key值是null</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="4-哈希算法，扩容，性能"><a href="#4-哈希算法，扩容，性能" class="headerlink" title="4.哈希算法，扩容，性能"></a>4.哈希算法，扩容，性能</h5><ul><li style="list-style: none"><input type="checkbox"> HashMap中的hash方法：</li></ul><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">static</span> fianl <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">&gt; <span class="keyword">int</span> h;</span><br><span class="line">&gt; <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li><p>(1).为何不采用Object类提供的hashCode方法计算出来的key值作为桶下标：</p><blockquote><p>基本不会发生碰撞，哈希表就和普通数组基本没有区别</p></blockquote></li><li><p>(2). 为何h &gt;&gt;&gt; 16?为何取出key值的高16位右移参与hash运算？</p><blockquote><p>因为hash基本是在高16位进行hash运算</p></blockquote></li><li><p>(3). 为何HashMap中容量均为2^n？</p><blockquote><p>(n-1) &amp; hash  当2为2^n,此时位运算就相当于hash % (n-1)</p></blockquote></li><li><p>[ ] <strong>扩容resize()</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Initializes(初始化) or doubles（扩2倍） table size（桶的个数）.  If null, allocates in</span></span><br><span class="line"><span class="comment">    * accord with initial capacity target held in field threshold.</span></span><br><span class="line"><span class="comment">    * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class="line"><span class="comment">    * elements from each bin must either stay at same index, or move</span></span><br><span class="line"><span class="comment">    * with a power of two offset in the new table（原来元素要么stay at same index,要么 move</span></span><br><span class="line"><span class="comment">    * with a power of two offset in the new table）.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">       <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">       <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">       <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//当前hash表已经达到最大值</span></span><br><span class="line">           <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">               threshold = Integer.MAX_VALUE;</span><br><span class="line">               <span class="keyword">return</span> oldTab;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//扩容为原hash表2倍</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">               newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">           newCap = oldThr;</span><br><span class="line">       <span class="comment">//进行hash表的初始化操作</span></span><br><span class="line">       <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">           newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">           newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">           newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">       &#125;</span><br><span class="line">       threshold = newThr;</span><br><span class="line">       <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">           Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">       table = newTab;</span><br><span class="line">       <span class="comment">//对原hash表的元素进行rehash</span></span><br><span class="line">       <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">               Node&lt;K,V&gt; e;</span><br><span class="line">               <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                   <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                       newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                       ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                   <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                       Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; next;</span><br><span class="line">                       <span class="keyword">do</span> &#123;</span><br><span class="line">                           next = e.next;</span><br><span class="line">                           <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                               <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                   loHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   loTail.next = e;</span><br><span class="line">                               loTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                   hiHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   hiTail.next = e;</span><br><span class="line">                               hiTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                       <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j] = loHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j + oldCap] = hiHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> newTab;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>1.负责哈希表的初始化操作</li><li>2.当表中元素个数达到阈值（容量*负载因子）后进行扩容为原哈希表的二倍（扩容的是桶的个数）</li><li>3.扩容后，原来元素进行rehash：要么元素还待在原桶中，要么待在double桶（扩容后的桶）中</li></ul><h5 id="5-性能问题"><a href="#5-性能问题" class="headerlink" title="5.性能问题"></a>5.性能问题</h5><h6 id="5-1多线程条件下："><a href="#5-1多线程条件下：" class="headerlink" title="5.1多线程条件下："></a>5.1多线程条件下：</h6><ul><li style="list-style: none"><input type="checkbox"> 在竞争激烈的场景下使用HashMap会造成CPU100%，解决：<strong>使用ConcurrentHashMap来代替rehash过程</strong></li></ul><h6 id="5-2性能主要开销：resize-后的rehash过程"><a href="#5-2性能主要开销：resize-后的rehash过程" class="headerlink" title="5.2性能主要开销：resize()后的rehash过程"></a>5.2性能主要开销：resize()后的rehash过程</h6><ul><li style="list-style: none"><input type="checkbox"> <strong>解决：在能预估存放元素个数的前提下传入适当的初始化参数来尽量避免resize()</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaSE基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>List中remove()陷阱</title>
      <link href="/2019/04/27/List%E4%B8%ADremove-%E9%99%B7%E9%98%B1/"/>
      <url>/2019/04/27/List%E4%B8%ADremove-%E9%99%B7%E9%98%B1/</url>
      
        <content type="html"><![CDATA[<h4 id="在做一道算法题："><a href="#在做一道算法题：" class="headerlink" title="在做一道算法题："></a>在做一道算法题：</h4><blockquote><p>找出下列数组中的缺失元素:</p><p>[2,4,5,7,10]</p><p>得到：[3, 6, 8, 9]</p></blockquote><h6 id="删除链表中与整型数组相同的元素。测试代码：（当然还有更简洁方法（如在添加链表元素时直接进行判断），此时为测试remove-方法如下：）"><a href="#删除链表中与整型数组相同的元素。测试代码：（当然还有更简洁方法（如在添加链表元素时直接进行判断），此时为测试remove-方法如下：）" class="headerlink" title="删除链表中与整型数组相同的元素。测试代码：（当然还有更简洁方法（如在添加链表元素时直接进行判断），此时为测试remove()方法如下：）"></a>删除链表中与整型数组相同的元素。测试代码：（当然还有更简洁方法（如在添加链表元素时直接进行判断），此时为测试remove()方法如下：）</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">10</span>&#125;;<span class="comment">//批量修改变量名：shift+F6</span></span><br><span class="line">       List&lt;Integer&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = nums[<span class="number">0</span>]; i &lt;= nums[nums.length - <span class="number">1</span>]; i++) &#123;</span><br><span class="line">           <span class="built_in">list</span>.add(i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (i &lt; nums.length) &#123;</span><br><span class="line">           <span class="keyword">if</span> (<span class="built_in">list</span>.get(j).equals((Integer)nums[i])) &#123;</span><br><span class="line">               <span class="built_in">list</span>.remove(nums[i]);</span><br><span class="line">               i++;</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               j++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="built_in">list</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以发现此时运行会出现<strong>IndexOutOfBoundsException</strong>，因为此时nums[i]是int类型，而remove方法是一个被重载的方法，根据传入参数有int型（既下标索引）和Object（对象）型的两种方法，此时则默认的是下标引索，肯定会出现越界异常。</p></blockquote><p><strong>解决办法：</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span>.<span class="keyword">remove</span>(Integer.valueOf(nums[i]));</span><br><span class="line">//或者<span class="keyword">list</span>.<span class="keyword">remove</span>((Integer)nums[i]);</span><br></pre></td></tr></table></figure><h4 id="拓展：-List的remove-方法陷阱"><a href="#拓展：-List的remove-方法陷阱" class="headerlink" title="拓展： List的remove()方法陷阱"></a>拓展： List的remove()方法陷阱</h4><h5 id="1-用for循环遍历List删除元素时，需要注意索引会左移的问题。"><a href="#1-用for循环遍历List删除元素时，需要注意索引会左移的问题。" class="headerlink" title="1.用for循环遍历List删除元素时，需要注意索引会左移的问题。"></a>1.用for循环遍历List删除元素时，需要注意索引会左移的问题。</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如：想删除所有的2</span></span><br><span class="line">        List&lt;Integer&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="built_in">list</span>.add(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">list</span>.add(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">list</span>.add(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">list</span>.add(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">list</span>.add(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">list</span>.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">list</span>.get(i)==<span class="number">2</span>) <span class="built_in">list</span>.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="built_in">list</span>);<span class="comment">//[0, 1, 2, 3]</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>此时发现漏掉了一个2，List调用remove(index)方法后，会移除index位置上的元素，index之后的元素就全部依次左移，即索引依次-1要保证能操作所有的数据，需要把index-1，否则原来索引为index+1的元素就无法遍历到(因为原来索引为index+1的数据，在执行移除操作后，索引变成index了，如果没有index-1的操作，就不会遍历到该元素，而是遍历该元素的下一个元素。</p></blockquote><ul><li><p>[ ] <strong>解决办法：</strong></p><p><strong>(1).让索引同步:</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>.remove(i<span class="comment">--);</span></span><br></pre></td></tr></table></figure><p><strong>(2).倒序遍历List删除元素</strong></p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(<span class="name">int</span> i=list.size()<span class="number">-1</span><span class="comment">;i&gt;=0;i--)&#123;</span></span><br><span class="line">if(<span class="name">list</span>.get(<span class="name">i</span>)==2)&#123;</span><br><span class="line">    list.remove(<span class="name">i</span>)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(3).迭代删除List元素</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; <span class="keyword">it</span>=<span class="built_in">list</span>.iterator();</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">it</span>.hasNext())&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">it</span>.next()==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">it</span>.remove();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="2-注意：for-each遍历List删除元素-和迭代遍历-用list-remove-i-方法删除元素-会出现错误"><a href="#2-注意：for-each遍历List删除元素-和迭代遍历-用list-remove-i-方法删除元素-会出现错误" class="headerlink" title="2.注意：for-each遍历List删除元素(和迭代遍历,用list.remove(i)方法删除元素)会出现错误"></a>2.注意：for-each遍历List删除元素(和迭代遍历,用list.remove(i)方法删除元素)会出现错误</h5><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for(<span class="built_in">Integer</span> i:<span class="built_in">list</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">list</span>.remove(i);<span class="comment">//ConcurrentModificationException</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------</span><br><span class="line">Iterator&lt;<span class="built_in">Integer</span>&gt; it=<span class="built_in">list</span>.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line"><span class="built_in">Integer</span> value=it.next();</span><br><span class="line"><span class="keyword">if</span>(value==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">list</span>.remove(value);<span class="comment">//ConcurrentModificationException</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>此时会出现<strong>ConcurrentModificationException</strong> ； for-each 写法实际上是对的 Iterable、hasNext、next方法的简写</p></blockquote><ul><li><p>[x] <strong>对于ConcurrentModificationException：</strong></p><ul><li><p><strong>fail-fast机制：</strong></p><ul><li><p>ConcurrentModificationExcetion发生在Collection集合使用迭代器遍历时，使用了集合类提供的修改集合内容方法报错。而如果使用Iterator迭代器的remove()不会出现此错误。</p></li><li><p><strong>出错机制：</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Collection 集合中的modCount表示当前集合的修改次数;</li><li>expectModcount是迭代器中记录当前集合的修改次数，当取得集合迭代器时（即调用list.iterator()）,exceptedModCount = modCount，换言之，迭代器就是当前集合的一个副本。</li></ul></li><li><p>快速失败策略保证了所有用户在进行迭代遍历集合时，拿到的数据一定是最新的数据。（避免“脏读产生”）</p></li><li><p><strong>总结：以后在迭代器遍历时，不要修改集合内容</strong></p></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaSE基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO流</title>
      <link href="/2019/04/26/IO%E6%B5%81/"/>
      <url>/2019/04/26/IO%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h3 id="JavaIO-BIO（阻塞式IO）-基于抽象类"><a href="#JavaIO-BIO（阻塞式IO）-基于抽象类" class="headerlink" title="JavaIO-BIO（阻塞式IO）-基于抽象类"></a>JavaIO-BIO（阻塞式IO）-基于抽象类</h3><h4 id="核心掌握五个类（-File、OutputStream、InputStream、Reader、Writer）-一个接口（Serializable）"><a href="#核心掌握五个类（-File、OutputStream、InputStream、Reader、Writer）-一个接口（Serializable）" class="headerlink" title="核心掌握五个类（ File、OutputStream、InputStream、Reader、Writer）+ 一个接口（Serializable）"></a>核心掌握五个类（ <a href>File、OutputStream、InputStream、Reader、Writer</a>）+ 一个接口（<a href>Serializable</a>）</h4><h5 id="1-File文件操作类-既可以描述具体文件也可描述文件夹"><a href="#1-File文件操作类-既可以描述具体文件也可描述文件夹" class="headerlink" title="1.File文件操作类-既可以描述具体文件也可描述文件夹"></a>1.File文件操作类-既可以描述具体文件也可描述文件夹</h5><ul><li style="list-style: none"><input type="checkbox"> File类是唯一一个与文件操作（创建、删除、取得信息）有关的程序类</li><li style="list-style: none"><input type="checkbox"> 产生File对象：</li><li>public File(String pathname):根据文件的绝对路径来产生File对象</li><li>public File(URI uri) : 根据网络产生File对象<h6 id="1-1常用操作方法"><a href="#1-1常用操作方法" class="headerlink" title="1.1常用操作方法"></a>1.1常用操作方法</h6></li><li style="list-style: none"><input type="checkbox"> 创建新文件：</li><li>public boolean creatNewFile() throws IOException</li><li style="list-style: none"><input type="checkbox"> 判断文件是否存在</li><li>public boolean exists()</li><li style="list-style: none"><input type="checkbox"> 删除文件</li><li>public boolean delete()</li><li style="list-style: none"><input type="checkbox"> 文件分隔符:File.separator<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Test &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="comment">//1.取得File对象</span></span><br><span class="line">        <span class="keyword">File</span> <span class="keyword">file</span> = <span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">"C:"</span>+<span class="keyword">File</span>.separator+<span class="string">"Users"</span>+<span class="keyword">File</span>.separator+</span><br><span class="line">            <span class="string">"DELL"</span>+<span class="keyword">File</span>.separator+<span class="string">"Desktop"</span>+<span class="keyword">File</span>.separator+<span class="string">"Test.java"</span>);</span><br><span class="line">        <span class="comment">//2、判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">file</span>.exists()) &#123;</span><br><span class="line">            <span class="keyword">file</span>.<span class="keyword">delete</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">file</span>.creatNewFile();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h6 id="1-2目录操作"><a href="#1-2目录操作" class="headerlink" title="1.2目录操作"></a>1.2目录操作</h6><ul><li style="list-style: none"><input type="checkbox"> 取得父路径的File对象</li><li>public File getParentFile()</li><li style="list-style: none"><input type="checkbox"> 取得父路径的目录</li><li>public String getParent()</li><li style="list-style: none"><input type="checkbox"> 创建多级父路径（一次性创建多级不存在的父路径）</li><li>public boolean mkdirs()<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Test &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="comment">//1.取得File对象</span></span><br><span class="line">        <span class="keyword">File</span> <span class="keyword">file</span> = <span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">"C:"</span>+<span class="keyword">File</span>.separator+<span class="string">"Users"</span>+<span class="keyword">File</span>.separator+</span><br><span class="line">            <span class="string">"DELL"</span>+<span class="keyword">File</span>.separator+<span class="string">"Desktop"</span>+<span class="keyword">File</span>.separator+<span class="string">"www"</span>+</span><br><span class="line">            <span class="keyword">File</span>.separator+<span class="string">"hbc"</span>+<span class="keyword">File</span>.separator+<span class="string">"Test.java"</span>);</span><br><span class="line">        <span class="comment">//2、判断父路径是否存在，不存在创建多级父路径</span></span><br><span class="line">        <span class="keyword">if</span> (！<span class="keyword">file</span>.getParentFile.exists()) &#123;</span><br><span class="line">            <span class="keyword">file</span>.getParentFile().mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断文件是否存在，不存在则创建文件</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">file</span>.exists()) &#123;</span><br><span class="line">            System.out.<span class="keyword">println</span>(<span class="string">"文件已存在"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">file</span>.creatNewFile();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h6 id="1-3取得文件信息"><a href="#1-3取得文件信息" class="headerlink" title="1.3取得文件信息"></a>1.3取得文件信息</h6><ul><li style="list-style: none"><input type="checkbox"> 判断File对象是否是文件</li><li>public boolean isFile()</li><li style="list-style: none"><input type="checkbox"> 判断File对象是否是文件夹</li><li>public boolean isDirectory()</li><li style="list-style: none"><input type="checkbox"> 取得文件大小-字节为单位（xx/1024就是多少kb）</li><li>public long length()</li><li style="list-style: none"><input type="checkbox"> 取得上次修改时间</li><li>public long lastModified()</li><li style="list-style: none"><input type="checkbox"> 列出一个目录的全部组成</li><li>public File[] listFiles()<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg:获取桌面上的所有文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Test &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="comment">//1.取得File对象</span></span><br><span class="line">        <span class="keyword">File</span> <span class="keyword">file</span> = <span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">"C:"</span>+<span class="keyword">File</span>.separator+<span class="string">"Users"</span>+<span class="keyword">File</span>.separator+</span><br><span class="line">            <span class="string">"DELL"</span>+<span class="keyword">File</span>.separator+<span class="string">"Desktop"</span>);</span><br><span class="line">        <span class="comment">//将IO操作放在子线程中</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            listAllFiles(<span class="keyword">file</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> listAllFiles(<span class="keyword">File</span> <span class="keyword">file</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">file</span>.isFile()) &#123;</span><br><span class="line">            System.out.<span class="keyword">println</span>(<span class="keyword">file</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">file</span>.exists() &amp;&amp; <span class="keyword">file</span>.isDirectory()) &#123;</span><br><span class="line">                <span class="keyword">File</span>[] file1 = <span class="keyword">file</span>.listFiles();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">File</span> file1 : files) &#123;</span><br><span class="line">                    listAllFiles(file1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="2-字节与字符流"><a href="#2-字节与字符流" class="headerlink" title="2.字节与字符流"></a>2.字节与字符流</h5><p><a href>java.io包流分为两类：输入流与输出流</a></p><h6 id="字节-byte-流-原生操作，无需转换-可以处理文本文件、图像、音乐、视频等资源InputStream-OutputStream"><a href="#字节-byte-流-原生操作，无需转换-可以处理文本文件、图像、音乐、视频等资源InputStream-OutputStream" class="headerlink" title="字节(byte)流:原生操作，无需转换,可以处理文本文件、图像、音乐、视频等资源InputStream OutputStream"></a>字节(byte)流:原生操作，无需转换,可以处理文本文件、图像、音乐、视频等资源<a href>InputStream OutputStream</a></h6><h6 id="字符-char-流：是经过处理后的操作，只用于处理中文文本-Reader-Writer"><a href="#字符-char-流：是经过处理后的操作，只用于处理中文文本-Reader-Writer" class="headerlink" title="字符(char)流：是经过处理后的操作，只用于处理中文文本  Reader Writer"></a>字符(char)流：是经过处理后的操作，只用于处理中文文本  <a href>Reader Writer</a></h6><h6 id="流模型的操作流程："><a href="#流模型的操作流程：" class="headerlink" title="流模型的操作流程："></a>流模型的操作流程：</h6><ul><li>1、取得终端对象</li><li>2、根据终端对象取得输入输出流</li><li>3、根据输入输出流进行数据读取与写入</li><li>4、关闭流</li><li style="list-style: none"><input type="checkbox"> <strong>IO操作属于资源处理，所有的资源处理（IO操作、数据库操作、网络操作）在使用后一定要关闭</strong></li></ul><h6 id="2-1字节输出流OutputStream"><a href="#2-1字节输出流OutputStream" class="headerlink" title="2.1字节输出流OutputStream"></a>2.1字节输出流OutputStream</h6><p><a href>public abstract class OutputStream implements Closeable, Flushable</a></p><ul><li style="list-style: none"><input type="checkbox"> 核心方法</li><li>public void write(byte b[]) throws IOExceptiion:将给定的字节数组全部输出</li><li>public void write(byte b[], int off, int len) throws IOException:将给定的字节数组以off位置开始输出len长度后停止输出</li><li>public abstract void write(int b) throws IOException:输出单个字节</li><li style="list-style: none"><input type="checkbox"> 使用OutputStream输出数据时，若指定文件不存在，FileOutputStream会自动创建文件（不包括创建目录）</li><li style="list-style: none"><input type="checkbox"> 使用FileOutputStream输出内容时，默认文件内容的覆盖操作。</li><li style="list-style: none"><input type="checkbox"> 若要进行文件内容追加，使用如下构造方法：</li><li>public FileOutputStream(File file, boolean append)</li><li style="list-style: none"><input type="checkbox"> JDK1.7追加了AutoCloseable自动关闭接口，要使用此接口，必须使用try-catch块<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Test &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="comment">//1.取得终端对象</span></span><br><span class="line">        <span class="keyword">File</span> <span class="keyword">file</span> = <span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">"C:"</span>+<span class="keyword">File</span>.separator+<span class="string">"Users"</span>+<span class="keyword">File</span>.separator+</span><br><span class="line">            <span class="string">"DELL"</span>+<span class="keyword">File</span>.separator+<span class="string">"Desktop"</span>+<span class="keyword">File</span>.separator+<span class="string">"Test.txt"</span>);</span><br><span class="line">        <span class="comment">//2.取得指定文件的输出流</span></span><br><span class="line">        OutputStresm out = <span class="keyword">new</span> FileOutputStream(<span class="keyword">file</span>,<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//3.进行 数据的输出</span></span><br><span class="line">        String str = <span class="string">"Hello world"</span>;</span><br><span class="line">        out.<span class="keyword">write</span>(str.getBytes(),<span class="number">6</span>,<span class="number">5</span>);<span class="comment">//getBytes()是将String类型的字符串转换为byte型并放入一个byte数组</span></span><br><span class="line">        <span class="comment">//4.关闭流</span></span><br><span class="line">        out.close();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h6 id="2-2-字节输入流InputStream"><a href="#2-2-字节输入流InputStream" class="headerlink" title="2.2 字节输入流InputStream"></a>2.2 字节输入流InputStream</h6><p><a href>public abstract class InputStream implements Closeable</a></p><ul><li style="list-style: none"><input type="checkbox"> 将读取的内容放入字节数组中</li><li>public int read(byte b[]) throws IOException</li><li style="list-style: none"><input type="checkbox"> 返回值有如下三种情况：</li><li>1.返回b.length：未读取的数据大于存放的缓冲区大小，返回字节数组大小</li><li>2.返回大于0的整数，此整数小于b.length：此时未读取的数据小于存放的缓冲区大小，返回剩余数据大小</li><li>3.返回-1：此时数据已经读取完毕（终止标记）<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg:</span></span><br><span class="line"><span class="keyword">public</span> class Test &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        <span class="comment">//1.取得终端对象</span></span><br><span class="line">        <span class="built_in">File</span> file = <span class="keyword">new</span> <span class="built_in">File</span>(<span class="string">"C:"</span>+<span class="built_in">File</span>.separator+<span class="string">"Users"</span>+<span class="built_in">File</span>.separator+</span><br><span class="line">            <span class="string">"DELL"</span>+<span class="built_in">File</span>.separator+<span class="string">"Desktop"</span>+<span class="built_in">File</span>.separator+<span class="string">"Test.txt"</span>);</span><br><span class="line">        <span class="comment">//2.取得相应的输入流</span></span><br><span class="line">        InputStresm in = <span class="keyword">new</span> FileIntputStream(file);</span><br><span class="line">        <span class="comment">//3.进行 数据的读取</span></span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = in.<span class="built_in">read</span>(data);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="keyword">new</span> <span class="keyword">String</span>(data,<span class="number">0</span>,len));</span><br><span class="line">        <span class="comment">//4.关闭流</span></span><br><span class="line">        in.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h6 id="2-3-字符输出流Writer-适用于处理中文文本"><a href="#2-3-字符输出流Writer-适用于处理中文文本" class="headerlink" title="2.3 字符输出流Writer-适用于处理中文文本"></a>2.3 字符输出流Writer-适用于处理中文文本</h6><p><a href>public void writer(String str) throws IOException</a></p><ul><li style="list-style: none"><input type="checkbox"> 字符流可以直接支持字符串的输出</li><li style="list-style: none"><input type="checkbox"> 字符流若未关闭，数据在缓冲区存放，不会输出到目标终端。要想将数据输出，要么将输出流关闭，要么使用flush强制刷新缓冲区<h6 id="2-4-字符输入流Reader"><a href="#2-4-字符输入流Reader" class="headerlink" title="2.4 字符输入流Reader"></a>2.4 字符输入流Reader</h6><a href>public int read(char cbuf[]) throws IOException</a><h5 id="3-转换流（字节流-gt-字符流）"><a href="#3-转换流（字节流-gt-字符流）" class="headerlink" title="3.转换流（字节流-&gt; 字符流）"></a>3.转换流（字节流-&gt; 字符流）</h5></li><li style="list-style: none"><input type="checkbox"> <strong>OutputStreamWriter</strong> (字节输出流-&gt;字符输出流)</li><li style="list-style: none"><input type="checkbox"> <strong>InputStreamReader</strong> (字节输入流-&gt;字符输入流)</li><li style="list-style: none"><input type="checkbox"> 字符流的具体子类大都是通过转换流将字节流转换为字符流（eg：FileWriter继承转换流）<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现文件的拷贝</span></span><br><span class="line"><span class="keyword">public</span> class Test &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) throws Exception&#123;</span><br><span class="line">        <span class="comment">//源文件路径</span></span><br><span class="line">        <span class="keyword">String</span> sourceFilePath = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">//目标文件路径</span></span><br><span class="line">        <span class="keyword">String</span> destFilePath = <span class="string">""</span>;</span><br><span class="line">        copyFlie(sourceFilePath,destFilePath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> copyFile(<span class="keyword">String</span> sourceFilePath,<span class="keyword">String</span> destFilePath) throws Exception &#123;</span><br><span class="line">        <span class="comment">//1.取得源文件与目标文件的File对象</span></span><br><span class="line">        <span class="built_in">File</span> sourceFile = <span class="keyword">new</span> <span class="built_in">File</span>(souceFilePath);</span><br><span class="line">        <span class="built_in">File</span> destFile = <span class="keyword">new</span> <span class="built_in">File</span>(destFilePath);</span><br><span class="line">        <span class="comment">//2.取得输入输出流</span></span><br><span class="line">        InputStream in = <span class="keyword">new</span> FileInputStream(sourceFile);</span><br><span class="line">        OutputStream out = <span class="keyword">new</span> FileOutStream(destFile);</span><br><span class="line">        <span class="comment">//3.数据输入输出</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">while</span>((len = in.<span class="built_in">read</span>(data)) != <span class="number">-1</span>) &#123;</span><br><span class="line">            out.<span class="built_in">write</span>(data,o,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="4-字符编码"><a href="#4-字符编码" class="headerlink" title="4.字符编码"></a>4.字符编码</h5><h6 id="1-GBK、GB2312："><a href="#1-GBK、GB2312：" class="headerlink" title="1.GBK、GB2312："></a>1.GBK、GB2312：</h6><ul><li style="list-style: none"><input type="checkbox"> GBK包含简体与繁体中文，GB2312只包含简体中文<h6 id="2-UNICODE："><a href="#2-UNICODE：" class="headerlink" title="2.UNICODE："></a>2.UNICODE：</h6></li><li style="list-style: none"><input type="checkbox"> java 提供的16进制编码，可以描述世界上任意语言，但是编码进制太高，编码体积较大。<h6 id="3-ISO-8859-1："><a href="#3-ISO-8859-1：" class="headerlink" title="3.ISO-8859-1："></a>3.ISO-8859-1：</h6></li><li style="list-style: none"><input type="checkbox"> 国际通用编码，不支持中文，浏览器默认编码。<h6 id="4-UTF编码："><a href="#4-UTF编码：" class="headerlink" title="4.UTF编码："></a>4.UTF编码：</h6></li><li style="list-style: none"><input type="checkbox"> 结合UNICODE与ISO-8859-1，最常采用的是UTF-8编码。</li><li style="list-style: none"><input type="checkbox"> 乱码产生原因：</li><li>编解码不一致（95%）</li><li>由于数据丢失造成的乱码（5%）<h5 id="5-内存流（以内存为终端的输入输出流）"><a href="#5-内存流（以内存为终端的输入输出流）" class="headerlink" title="5.内存流（以内存为终端的输入输出流）"></a>5.内存流（以内存为终端的输入输出流）</h5><h6 id="字节内存流"><a href="#字节内存流" class="headerlink" title="字节内存流"></a>字节内存流</h6><a href>ByteArrayInputStream、ByteArrayOutputStream</a><h6 id="字符内存流"><a href="#字符内存流" class="headerlink" title="字符内存流"></a>字符内存流</h6><a href>CharArrayReader、CharArrayWrier</a><h5 id="6-打印流"><a href="#6-打印流" class="headerlink" title="6.打印流"></a>6.打印流</h5><h6 id="字节打印流：PrintStream"><a href="#字节打印流：PrintStream" class="headerlink" title="字节打印流：PrintStream"></a>字节打印流：PrintStream</h6><h6 id="字符打印流：PrintWriter"><a href="#字符打印流：PrintWriter" class="headerlink" title="字符打印流：PrintWriter"></a>字符打印流：PrintWriter</h6></li><li style="list-style: none"><input type="checkbox" checked> 打印流的设计属于 ==装饰设计模式== -基于抽象类</li><li>特点：核心依然是某个类的（OutputStream提供的write()）的功能，<br>但是为了得到更好的操作效果，让其支持的功能更多一些，使用装饰类（PrintStream）</li><li>优点：很容易更换装饰类来达到不同的操作效果</li><li>缺点：造成类结构复杂<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">package www.hbc.printDemo;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">import</span> java.io.<span class="built_in">File</span>;</span><br><span class="line">        <span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line">        <span class="keyword">import</span> java.io.IOException;</span><br><span class="line">        <span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @Author: Beer</span></span><br><span class="line"><span class="comment"> * @Date: 2019/4/7 19:07</span></span><br><span class="line"><span class="comment"> * @Description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">class PrintUtil &#123;</span><br><span class="line">    <span class="keyword">private</span> OutputStream out;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PrintUtil(OutputStream out) &#123;</span><br><span class="line">        <span class="keyword">this</span>.out = out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">print</span>(<span class="keyword">String</span> str) &#123;</span><br><span class="line">        <span class="built_in">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.out.<span class="built_in">write</span>(str.getBytes());</span><br><span class="line">        &#125; <span class="built_in">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">println</span>(<span class="keyword">String</span> str) &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">print</span>(str + <span class="string">"\r\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">print</span>(<span class="keyword">int</span> data) &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">print</span>(<span class="keyword">String</span>.valueOf(data));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">println</span>(<span class="keyword">int</span> data) &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">print</span>(data + <span class="string">"\r\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">print</span>(<span class="keyword">double</span> data) &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">print</span>(<span class="keyword">String</span>.valueOf(data));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">println</span>(<span class="keyword">double</span> data) &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">print</span>(data + <span class="string">"\r\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">close</span>() &#123;</span><br><span class="line">        <span class="built_in">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.out.<span class="built_in">close</span>();</span><br><span class="line">        &#125; <span class="built_in">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class TestPrintUtil &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) throws Exception&#123;</span><br><span class="line">        <span class="comment">//1.取得File对象</span></span><br><span class="line">        <span class="built_in">File</span> file = <span class="keyword">new</span> <span class="built_in">File</span>(<span class="string">"C:\\Users\\DELL\\Desktop\\TextIO.txt"</span>);</span><br><span class="line">        <span class="comment">//2.取得输出流</span></span><br><span class="line">        PrintUtil <span class="built_in">print</span> = <span class="keyword">new</span> PrintUtil(<span class="keyword">new</span> FileOutputStream(file));</span><br><span class="line">        <span class="comment">//3.数据输入</span></span><br><span class="line">        <span class="built_in">print</span>.<span class="built_in">print</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="built_in">print</span>.<span class="built_in">println</span>(<span class="number">20.9</span>);</span><br><span class="line">        <span class="built_in">print</span>.<span class="built_in">println</span>(<span class="string">"Hello"</span>);</span><br><span class="line">        <span class="comment">//4.关闭流</span></span><br><span class="line">        <span class="built_in">print</span>.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="7-System类对IO的支持"><a href="#7-System类对IO的支持" class="headerlink" title="7.System类对IO的支持"></a>7.System类对IO的支持</h5><h6 id="标准输出（显示屏）：System-out"><a href="#标准输出（显示屏）：System-out" class="headerlink" title="标准输出（显示屏）：System.out"></a>标准输出（显示屏）：System.out</h6><h6 id="标准输入（键盘）：System-in"><a href="#标准输入（键盘）：System-in" class="headerlink" title="标准输入（键盘）：System.in"></a>标准输入（键盘）：System.in</h6><h6 id="错误输出：System-err"><a href="#错误输出：System-err" class="headerlink" title="错误输出：System.err"></a>错误输出：System.err</h6><h6 id="7-1系统输出"><a href="#7-1系统输出" class="headerlink" title="7.1系统输出"></a>7.1系统输出</h6><ul><li style="list-style: none"><input type="checkbox"> 系统提供的out（输出到显示器颜色为黑色）、err（输出到显示器颜色为黑色）对象均是PrintStream的对象</li><li style="list-style: none"><input type="checkbox"> 以后输出采用日志（Log）-格式化输出<h6 id="7-2-系统输入"><a href="#7-2-系统输入" class="headerlink" title="7.2 系统输入"></a>7.2 系统输入</h6></li><li style="list-style: none"><input type="checkbox"> System.in是InputStream的直接对象<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestSystemIn</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws Exception</span>&#123;</span><br><span class="line">        InputStream <span class="keyword">in</span> = System.<span class="keyword">in</span>;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"请输入内容："</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        len = <span class="keyword">in</span>.read(data);</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"输入的内容为：\n"</span> + <span class="keyword">new</span> String(data,<span class="number">0</span>,len));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="8-两种输入流"><a href="#8-两种输入流" class="headerlink" title="8.两种输入流"></a>8.两种输入流</h5><h6 id="8-1-BufferedReader、BufferedInputStream-readLine-直接读取一行输入，默认以回车结束）"><a href="#8-1-BufferedReader、BufferedInputStream-readLine-直接读取一行输入，默认以回车结束）" class="headerlink" title="8.1 BufferedReader、BufferedInputStream(readLine()直接读取一行输入，默认以回车结束）"></a>8.1 BufferedReader、BufferedInputStream(readLine()直接读取一行输入，默认以回车结束）</h6><h6 id="8-2-java-util-Scanner"><a href="#8-2-java-util-Scanner" class="headerlink" title="8.2 java.util.Scanner"></a>8.2 java.util.Scanner</h6><p>支持正则表达式</p><ul><li style="list-style: none"><input type="checkbox"> hasNextXxx():判断是否有指定类型数据输入</li><li style="list-style: none"><input type="checkbox"> netXx():获取指定类型数据</li><li style="list-style: none"><input type="checkbox"> useDelimiter(“指定分隔符”)<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestScanner</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws Exception</span> &#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.<span class="keyword">in</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"请输入出生日期:"</span>);</span><br><span class="line">        scanner.useDelimiter(<span class="string">"\n"</span>);<span class="comment">//以回车为分隔符</span></span><br><span class="line">        <span class="keyword">if</span> (scanner.hasNext(<span class="string">"\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;"</span>)) &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"出生日期为："</span> + scanner.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaSE基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合框架</title>
      <link href="/2019/04/24/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
      <url>/2019/04/24/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="Java类集（数据结构-多线程）-java-util"><a href="#Java类集（数据结构-多线程）-java-util" class="headerlink" title="Java类集（数据结构-多线程）-java.util.*"></a>Java类集（数据结构-多线程）-java.util.*</h3><p><a href>动态数组(当元素个数达到最大值时，动态增加容量)</a></p><h4 id="1-Java类集产生-JDK1-2"><a href="#1-Java类集产生-JDK1-2" class="headerlink" title="1.Java类集产生-JDK1.2"></a>1.Java类集产生-JDK1.2</h4><p><strong>动态数组：解决定长问题</strong></p><h5 id="1-2-Collection接口-单个对象保存的最顶层父接口"><a href="#1-2-Collection接口-单个对象保存的最顶层父接口" class="headerlink" title="1.2 Collection接口-单个对象保存的最顶层父接口"></a>1.2 Collection接口-<a href>单个对象</a>保存的最顶层父接口</h5><ul><li style="list-style: none"><input type="checkbox" checked> Collection接口及其子接口，在每次进行数据操作时只能对单个对象进行处理。</li><li>public interface Collection<e> extends Iterable<e></e></e></li><li style="list-style: none"><input type="checkbox" checked> Iterable<e>:迭代器接口（就是为了遍历集合）</e></li><li style="list-style: none"><input type="checkbox" checked> iterator<t> iterator();(取得集合的迭代器，JDK1.5之前直接写在Collection接口中)</t></li><li style="list-style: none"><input type="checkbox" checked> Collection接口中提供的核心方法：</li><li><a href>add(T t):向类集中添加元素</a></li><li><a href>iterator():取得类集的迭代器</a></li><li>Collection接口只定义了存储数据的标准，但无法区分存储类型。因此在实际中往往使用两个子接口List（允许数据重复）、Set（不允许数据重复）。一般不直接使用Collection接口。<h4 id="2-List接口"><a href="#2-List接口" class="headerlink" title="2.List接口"></a>2.List接口</h4>在进行单个集合处理时，优先考虑List接口</li><li style="list-style: none"><input type="checkbox" checked> 在List接口中拓展了两个重要方法（List接口独有）</li><li>public E get(int index) :根据索引下标取得数据；</li><li>public E set(int index,E element) :根据索引下标更新数据，返回修改前数据</li><li style="list-style: none"><input type="checkbox" checked> List接口有三个重要子类<a href>ArrayList(90%)、Vector、LinkedList</a>,这三个子类在使用上没有任何区别</li><li style="list-style: none"><input type="checkbox" checked> List接口要保存自定义类的对象，该类必须覆写equals()来使用contains()、remove()等方法<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//覆写equals()方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> boolean equals(Object obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (!(obj instanceof Person)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向下转型还原为Person对象</span></span><br><span class="line">    Person person = (Person) obj;</span><br><span class="line">    retrun <span class="keyword">this</span>.age.equals(per.age) &amp;&amp; <span class="keyword">this</span>.name.equals(per.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="Important-ArrayList、Vector、LinkedList的区别："><a href="#Important-ArrayList、Vector、LinkedList的区别：" class="headerlink" title="[Important]:==ArrayList、Vector、LinkedList的区别：=="></a>[Important]:==ArrayList、Vector、LinkedList的区别：==</h5><ul><li style="list-style: none"><input type="checkbox"> ArrayList、LinkedList的区别： </li><li>1、出现版本：ArrayList –&gt;JDK1.2 而Vector–&gt;JDK1.0(出现在List、Collection接口之前)</li><li>2、初始化策略区别：Vector在无参构造执行后将对象数组大小初始化为10；ArrayList采用懒加载策略，在构造方法阶段并不初始化对象数组，在第一次添加元素时才初始化对象数组大小为10</li><li>3、扩容策略：ArrayList扩容时，新数组变为原数组的1.5倍，Vector扩容时，新数组大小变为原数组的2倍；</li><li>4、线程安全性：ArrayList采用异步处理，线程不安全，效率较高；Vector采用方法上加锁(synchronized关键字(同步的，代表这个方法加锁))，线程安全，效率较低。（即便使用线程安全的List，也不用Vector）</li><li>5、遍历：Vector支持较老的Enumeration，ArrayList不支持，ArrayList支持Iterator、ListIterator、foreach；Vector支持Iterator、ListIterator、foreach、<br>Enumeration。</li><li style="list-style: none"><input type="checkbox"> ArrayList、Vector的共同点：底层均使用数组实现</li><li style="list-style: none"><input type="checkbox" checked> ArrayList、LinkedList区别：LinkedList底层采用双向链表实现，ArrayList底层采用数组实现<h3 id="3-Set接口"><a href="#3-Set接口" class="headerlink" title="3.Set接口"></a>3.Set接口</h3></li><li style="list-style: none"><input type="checkbox" checked> <strong>不允许数据重复（Set接口就是Value值相同的Map集合，先有Map才有Set），Set接口没有扩充方法</strong><h4 id="Set接口常用子类："><a href="#Set接口常用子类：" class="headerlink" title="Set接口常用子类："></a>Set接口常用子类：</h4><h5 id="HashSet（无序存储）-HashMap："><a href="#HashSet（无序存储）-HashMap：" class="headerlink" title="HashSet（无序存储）-HashMap："></a>HashSet（无序存储）-HashMap：</h5></li><li style="list-style: none"><input type="checkbox"> 1、底层使用 哈希表+红黑树</li><li style="list-style: none"><input type="checkbox"> 2、允许存放null，无序存储<h5 id="TreeSet（有序存储）-TreeMap：Comparable、Compartor"><a href="#TreeSet（有序存储）-TreeMap：Comparable、Compartor" class="headerlink" title="TreeSet（有序存储）- TreeMap：Comparable、Compartor"></a>TreeSet（有序存储）- TreeMap：Comparable、Compartor</h5></li><li style="list-style: none"><input type="checkbox"> 1、底层使用红黑树</li><li style="list-style: none"><input type="checkbox"> 2、不允许出现null，有序存储</li><li style="list-style: none"><input type="checkbox"> 3、自定义类要想保存到TreeSet中，要么实现Comparable接口，要么向TreeSet传入比较器（Comparator接口）<h6 id="Comparable与Commparator的区别："><a href="#Comparable与Commparator的区别：" class="headerlink" title="Comparable与Commparator的区别："></a>Comparable与Commparator的区别：</h6></li><li style="list-style: none"><input type="checkbox"> 在Java中，若想实现自定义类的比较，提供了以下两个接口：<blockquote><p><strong>java.lang.Comparable接口（内部比较器）-排序接口</strong>：</p></blockquote></li><li>若一个类实现了Comparable接口，就意味着该类支持排序。存放该类的Collection或数组，可以直接通过Collections.sort()或Array.sort()进行排序。</li><li>实现了Comparable接口的类可以直接放在TreeSet或TreeMap中</li><li><a href>public int compareTo(); 返回值三种情况：</a><strong>返回正数</strong>：表示当前对象大于目标对象；<strong>返回0</strong>：表示当前对象等于目标对象；<strong>返回负数</strong> ：表示当前对象小于目标对象<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//覆写compareTo,自定义Person类如何比较大小（按年龄）</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> int compareTo(Person o) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.age &gt; o.age) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.age &lt; o.age) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(o.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>Comparator(外部排序接口):</strong></p><ul><li>若要控制某个自定义类的顺序，而该类本身不支持排序（该类本身没有实现Comparable接口）。我们可以建立一个该类的“比较器”来进行排序。比较器实现Comparator接口即可。</li><li>“比较器”：实现了Comparator接口的类作为比较器，通过该比较器来进行类的排序。</li><li><a href>public int compare(T o1, T o2);返回值与compareTo返回值完全一样：</a>返回正数：o1 &gt; o2;返回0：o1 = o2;返回负数：o1 &lt; o2;</li><li>实现了Comparator接口进行第三方排序- <strong>策略模式</strong> ，此方法更加灵活，可以轻松改变策略进行第三方的排序算法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person类的比较器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AscAgeComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1,Person o2)</span> </span>&#123;</span><br><span class="line">        reeturn o1.getAge() - o2.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//只重写了compare方法，而equals方法在Object类中就已经写了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h5 id="Comparable接口与Comparator接口的关系："><a href="#Comparable接口与Comparator接口的关系：" class="headerlink" title="Comparable接口与Comparator接口的关系："></a>Comparable接口与Comparator接口的关系：</h5><ul><li style="list-style: none"><input type="checkbox" checked> Comparable 是排序接口，若一个类实现了Comparable接口，意味着该类支持排序，是一个内部比较器（自己和别人去比）</li><li style="list-style: none"><input type="checkbox" checked> Comparator接口是比较器接口，类本身不支持排序，专门有若干个第三方的比较器（实现了Comparator接口）来进行排序比较，是一个外部比较器（策略模式）<h5 id="重复元素的判断："><a href="#重复元素的判断：" class="headerlink" title="重复元素的判断："></a>重复元素的判断：</h5></li><li style="list-style: none"><input type="checkbox" checked> TreeSet与TreeMap依靠Comparator或Comparable接口来区分重复元素。<h5 id="自定义类要想保存在TreeMap或TreeSet中："><a href="#自定义类要想保存在TreeMap或TreeSet中：" class="headerlink" title="自定义类要想保存在TreeMap或TreeSet中："></a>自定义类要想保存在TreeMap或TreeSet中：</h5></li><li style="list-style: none"><input type="checkbox"> 要么该类直接实现Comparable接口，覆写compareTo方法</li><li style="list-style: none"><input type="checkbox"> 要么实现一个比较器，传入TreeSet或TreeMap来进行外部比较<h5 id="而HashSet与HashMap并不依赖比较接口。此时要想区分自定义元素是否重复，需要同时覆写equals与hashCode方法"><a href="#而HashSet与HashMap并不依赖比较接口。此时要想区分自定义元素是否重复，需要同时覆写equals与hashCode方法" class="headerlink" title="而HashSet与HashMap并不依赖比较接口。此时要想区分自定义元素是否重复，需要同时覆写equals与hashCode方法"></a>而HashSet与HashMap并不依赖比较接口。此时要想区分自定义元素是否重复，需要同时覆写equals与hashCode方法</h5></li><li style="list-style: none"><input type="checkbox"> 首先覆写equals()方法来判定元素内容是否相等。</li><li style="list-style: none"><input type="checkbox"> 覆写equals方法原则：</li><li>自反性：对于任何非空引用值想x, x.equals(x)都返回true</li><li>对称性：对于任何非空x,y,当且仅当x.equals(y)返回true，y.equals(x)也返回true</li><li>传递性：对于任何非空x,y,z,若x.equals(y)返回true，y.equals(z)返回true，一定有x.equals(z)返回true</li><li>一致性：对于任何非空的x,y,若想x与y的属性没有发生改变，则多次调用x.equals(y)始终返回true或false</li><li>非空性：对于任何的非空x，x.equals(null)一定返回false</li><li style="list-style: none"><input type="checkbox"> 先调用hashCode计算出hash码决定存放的数据桶，而后使用equals来比较元素是否相等，若相等，则不放置元素；若equals返回false。则在相同桶之后，使用链表将若干元素链起来。（先hashCode，若在一个数据桶再equals）</li><li><p>Object类提供的hashCode方法默认使用对象的地址进行hash</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//覆写hashCode ，把两个值做hash，而不是地址，hashCode保证属性值相同的元素一定在一个桶中，equals方法保证若是不一个东西就set</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> Objects.<span class="title">hash</span><span class="params">(age,name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>[ ] <strong>若两个equals方法返回true，他们的hashCode必然保证相等（相同值的hash码一定相等）。但两对象的hashCode相等equals不一定相等，当且仅当equals与hashCode均返回true，才认为两个对象真的相等</strong></p></li><li style="list-style: none"><input type="checkbox"> 哈希表：优化查找次数<h3 id="4-集合输出-迭代器输出-Iterator接口"><a href="#4-集合输出-迭代器输出-Iterator接口" class="headerlink" title="4. 集合输出(迭代器输出)-Iterator接口"></a>4. 集合输出(迭代器输出)-Iterator接口</h3></li><li style="list-style: none"><input type="checkbox"> 迭代器：为了遍历集合而生。-迭代器模式<h4 id="Iterator接口的两个核心方法："><a href="#Iterator接口的两个核心方法：" class="headerlink" title="Iterator接口的两个核心方法："></a>Iterator接口的两个核心方法：</h4></li><li style="list-style: none"><input type="checkbox"> <a href>boolean hasNext(); 判断是否还有元素</a></li><li style="list-style: none"><input type="checkbox"> <a href>E next(); 取得下一个元素</a><h5 id="4-1迭代器输出Iterator-只能从前向后输出"><a href="#4-1迭代器输出Iterator-只能从前向后输出" class="headerlink" title="4.1迭代器输出Iterator-只能从前向后输出"></a>4.1迭代器输出Iterator-只能从前向后输出</h5></li><li style="list-style: none"><input type="checkbox"> 调用Collection集合的子类Iterator方法取得内置迭代器，使用以下格式输出：<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">iterator</span>.hasNext()) &#123;</span><br><span class="line">    <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="keyword">iterator</span>.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="4-2-双向迭代接口ListIterator-List支持，Set不支持"><a href="#4-2-双向迭代接口ListIterator-List支持，Set不支持" class="headerlink" title="4.2 双向迭代接口ListIterator-List支持，Set不支持"></a>4.2 双向迭代接口ListIterator-List支持，Set不支持</h5><ul><li style="list-style: none"><input type="checkbox"> 除了hasNext与next方法外，还有：</li><li>hasPrevious():判断是否有上一个元素</li><li>previous：取得上一个元素</li><li style="list-style: none"><input type="checkbox"> 要想使用从后向前遍历输出，首先至少要从前向后遍历一次才可使用<h5 id="4-3-Enumeration（JDK1-0）枚举输出-Vector类支持"><a href="#4-3-Enumeration（JDK1-0）枚举输出-Vector类支持" class="headerlink" title="4.3 Enumeration（JDK1.0）枚举输出-Vector类支持"></a>4.3 Enumeration（JDK1.0）枚举输出-Vector类支持</h5></li><li style="list-style: none"><input type="checkbox"> hasMoreElements():判断是否有下一个元素</li><li style="list-style: none"><input type="checkbox"> nextElements():取得下一个元素<h5 id="4-4-for-each输出（所有子类都满足）"><a href="#4-4-for-each输出（所有子类都满足）" class="headerlink" title="4.4 for-each输出（所有子类都满足）"></a>4.4 for-each输出（所有子类都满足）</h5></li><li style="list-style: none"><input type="checkbox"> 能使用for-each输出的本质在于各个集合类都内置迭代器</li></ul><h5 id="fail-fast机制："><a href="#fail-fast机制：" class="headerlink" title="fail-fast机制："></a>fail-fast机制：</h5><ul><li><p>[ ] ConcurrentModificationExcetion发生在Collection集合使用迭代器遍历时，使用了集合类提供的修改集合内容方法报错。而如果使用Iterator迭代器的remove()不会出现此错误。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出错机制：</span></span><br><span class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Collection 集合中的modCount表示当前集合的修改次数</p></li><li>expectModcount是迭代器中记录当前集合的修改次数，当取得集合迭代器时（即调用list.iterator()）,exceptedModCount = modCount，换言之，迭代器就是当前集合的一个副本。</li><li>快速失败策略保证了所有用户在进行迭代遍历集合时，拿到的数据一定是最新的数据。（避免“脏读产生”）</li><li><strong>fail-safe:</strong> 不产生ConCurrentModificationException异常，jar包下所有的线程安全集合（CopyOnWriteArrayList）</li><li><strong>总结：以后在迭代器遍历时，不要修改集合内容</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Strring&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Collections.addAll(<span class="built_in">list</span>,<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>,<span class="string">"D"</span>,<span class="string">"E"</span>);</span><br><span class="line">        <span class="comment">//modCount = 6</span></span><br><span class="line">        Iterator&lt;String&gt; iterator = <span class="built_in">list</span>.iterator();</span><br><span class="line">        <span class="comment">//取得集合迭代器（取得当前集合的副本）</span></span><br><span class="line">        <span class="comment">//expectedModCount = 6</span></span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">            <span class="comment">//调用checkForComodification检查副本中的exceptedModCount是否等于集合的modCount</span></span><br><span class="line">            String str = iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (strr.equals(<span class="string">"B"</span>)) &#123;</span><br><span class="line">                <span class="comment">//list.remove("B");//集合类提供的remove方法，报错：ConcurrentModeficationException;</span></span><br><span class="line">                iterator.remove(<span class="string">"B"</span>);<span class="comment">//正确</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-Map集合"><a href="#5-Map集合" class="headerlink" title="5.Map集合"></a>5.Map集合</h2><h5 id="Map接口是Java中保存二元偶对象（键值对）的最顶层接口"><a href="#Map接口是Java中保存二元偶对象（键值对）的最顶层接口" class="headerlink" title="Map接口是Java中保存二元偶对象（键值对）的最顶层接口"></a>Map接口是Java中保存二元偶对象（键值对）的最顶层接口</h5><p><a href>public interface Map&lt;K,V&gt; key值唯一，通过key值一定能唯一找到一个value值</a></p><h5 id="Map接口中的核心方法："><a href="#Map接口中的核心方法：" class="headerlink" title="Map接口中的核心方法："></a>Map接口中的核心方法：</h5><ul><li><strong>public V put(K key,V value):向Map中添加数据</strong></li><li><strong>public V get(K key) :根据指定的key值取得相应的value值，若没有key值则返回null</strong></li><li><a href>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() : 将Map集合变为Set集合</a></li><li><strong>public Set<k> keySet()</k></strong> : 返回所有key值，<strong>key不能重复</strong>。</li><li><strong>public Collection<v> values()</v></strong> : 返回所有value值，<strong>value可以重复</strong>。<h4 id="Map接口有如下常用子类："><a href="#Map接口有如下常用子类：" class="headerlink" title="Map接口有如下常用子类："></a>Map接口有如下常用子类：</h4><a href>HashMap、TreeMap、HashTable、ConcurrentHashMap</a></li></ul><h4 id="HashMap与HashTable区别："><a href="#HashMap与HashTable区别：" class="headerlink" title="HashMap与HashTable区别："></a>HashMap与HashTable区别：</h4><ul><li style="list-style: none"><input type="checkbox"> HashMap-类比HashSet</li><li>1.允许key和value为null，且key值有且只有一个为null，value可以有任意多个为null</li><li>2.JDK1.2产生</li><li>3.异步处理效率高，线程不安全</li><li>4.底层：hash表+红黑树（JDK8）</li><li style="list-style: none"><input type="checkbox"> HashTable</li><li>1.key与value均不为null</li><li>2.JDK1.0产生</li><li>3.使用方法加锁，效率低，线程安全</li><li>4.底层hash表<h4 id="Map集合使用迭代器输出："><a href="#Map集合使用迭代器输出：" class="headerlink" title="Map集合使用迭代器输出："></a>Map集合使用迭代器输出：</h4></li><li style="list-style: none"><input type="checkbox"> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet():将Map集合转为Set集合<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class TestMapIterator &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        Map&lt;Integer, <span class="keyword">String</span>&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="built_in">map</span>.<span class="built_in">put</span>(<span class="number">1</span>, <span class="string">"Java"</span>);</span><br><span class="line">        <span class="built_in">map</span>.<span class="built_in">put</span>(<span class="number">2</span>, <span class="string">"C++"</span>);</span><br><span class="line">        <span class="built_in">map</span>.<span class="built_in">put</span>(<span class="number">3</span>, <span class="string">"Python"</span>);</span><br><span class="line">        <span class="comment">//Map——&gt;Set</span></span><br><span class="line">        Set&lt;Map.Entry&lt;Integer, <span class="keyword">String</span>&gt;&gt; set = <span class="built_in">map</span>.entrySet();</span><br><span class="line">        <span class="comment">//取得Set接口迭代器</span></span><br><span class="line">        Iterator&lt;Map.Entry&lt;Integer, <span class="keyword">String</span>&gt;&gt; iterator = set.iterator();</span><br><span class="line">        <span class="comment">//迭代输出</span></span><br><span class="line">        <span class="built_in">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;Integer, <span class="keyword">String</span>&gt; entry = iterator.next();</span><br><span class="line">            System.out.<span class="built_in">println</span>(entry.<span class="built_in">getKey</span>() + <span class="string">"="</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-栈和队列"><a href="#6-栈和队列" class="headerlink" title="6.栈和队列"></a>6.栈和队列</h3><h4 id="栈：先入后出-Vector"><a href="#栈：先入后出-Vector" class="headerlink" title="栈：先入后出-Vector"></a>栈：先入后出-Vector</h4><p> <strong>应用：</strong> 函数栈帧，浏览器网页的后腿，安卓Activity的后退 ，编译器撤销</p><ul><li>入栈：push</li><li>出栈：pop</li><li>返回栈顶元素但不出栈：peek()</li><li style="list-style: none"><input type="checkbox"> 自己实现一个html识别器：<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> <span class="keyword">Test</span> &#123;</span><br><span class="line">    public static void mian(String[] <span class="keyword">args</span>) &#123;</span><br><span class="line">        <span class="keyword">Stack</span> <span class="keyword">stack</span> = new <span class="keyword">Stack</span>();</span><br><span class="line">        <span class="keyword">stack</span>.push(1);</span><br><span class="line">        <span class="keyword">stack</span>.push(2);</span><br><span class="line">        <span class="keyword">stack</span>.push(3);</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="keyword">stack</span>.peek());<span class="comment">//3</span></span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="keyword">stack</span>.pop());<span class="comment">//3</span></span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="keyword">stack</span>.pop());<span class="comment">//2</span></span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="keyword">stack</span>.pop());<span class="comment">//1</span></span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="keyword">stack</span>.pop());<span class="comment">//报错：EmptyStackException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="队列FIFO：先入先出"><a href="#队列FIFO：先入先出" class="headerlink" title="队列FIFO：先入先出"></a>队列FIFO：先入先出</h4><p><strong>Queue接口-LinkedList</strong></p><p><a href>Queue<integer> queue = new LinkedList&lt;&gt;();</integer></a> </p><ul><li>入队列：add()</li><li>出队列：poll()</li><li>返回队列头元素，不出对：peek()</li><li>消息队列：kafka,RobitMQ<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mian</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         Queue&lt;Integer&gt; <span class="built_in">queue</span> = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">         <span class="built_in">queue</span>.push(<span class="number">1</span>);</span><br><span class="line">         <span class="built_in">queue</span>.push(<span class="number">2</span>);</span><br><span class="line">         <span class="built_in">queue</span>.push(<span class="number">3</span>);</span><br><span class="line">         System.out.println(<span class="built_in">stack</span>.peek());<span class="comment">//1</span></span><br><span class="line">         System.out.println(<span class="built_in">stack</span>.poll());<span class="comment">//1</span></span><br><span class="line">         System.out.println(<span class="built_in">stack</span>.poll());<span class="comment">//2</span></span><br><span class="line">         System.out.println(<span class="built_in">stack</span>.poll());<span class="comment">//3</span></span><br><span class="line">         System.out.println(<span class="built_in">stack</span>.poll());<span class="comment">//null</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="7-资源文件操作（Properties属性文件）"><a href="#7-资源文件操作（Properties属性文件）" class="headerlink" title="7.资源文件操作（Properties属性文件）"></a>7.资源文件操作（Properties属性文件）</h3><p>**资源文件内容都是k-v 格式，并且无论key、value都是String类型</p><h5 id="设置属性"><a href="#设置属性" class="headerlink" title="设置属性"></a>设置属性</h5><ul><li>setProperty(String key,String value) 返回Object<h5 id="取得属性"><a href="#取得属性" class="headerlink" title="取得属性"></a>取得属性</h5></li><li>getProperty(String key,String value) 返回String,若没有指定key，返回null</li><li>getProperty(String key,String defaultValue):若没有指定key值返回默认值<h5 id="将资源内容输入输出到目标终端"><a href="#将资源内容输入输出到目标终端" class="headerlink" title="将资源内容输入输出到目标终端"></a>将资源内容输入输出到目标终端</h5></li><li>输出到目标终端：store(OutputStream out,String comments);</li><li>从目标终端中读取数据：load(InputStream in);<h3 id="8-Collections工具类"><a href="#8-Collections工具类" class="headerlink" title="8.Collections工具类"></a>8.Collections工具类</h3><h5 id="1-将线程不安全的集合包装为线程安全的集合"><a href="#1-将线程不安全的集合包装为线程安全的集合" class="headerlink" title="1.将线程不安全的集合包装为线程安全的集合"></a>1.将线程不安全的集合包装为线程安全的集合</h5></li><li style="list-style: none"><input type="checkbox"> 在add、remove等方法修改上使用了同步代码块保证线程安全，效率较低。<strong>要使用线程安全集合，推荐使用juc包下的并发集合类（ConcurrentHashMap、CopyOnWriteArrayList）</strong></li><li style="list-style: none"><input type="checkbox"> 集合排序</li><li>Collection.sort(集合名称)</li><li style="list-style: none"><input type="checkbox"> 集合反转</li><li>Collections.reverse(集合名称)<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCollections01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(String[] args) &#123;</span><br><span class="line">        <span class="keyword">List</span>&lt;String&gt; <span class="keyword">list</span> = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//向集合中一次添加多个元素</span></span><br><span class="line">        Collections.addAll(<span class="keyword">list</span>, <span class="string">"A"</span>, <span class="string">"a"</span>, <span class="string">"k"</span>, <span class="string">"K"</span>, <span class="string">"B"</span>, <span class="string">"b"</span>);</span><br><span class="line">        <span class="comment">//集合排序</span></span><br><span class="line">        Collections.sort(<span class="keyword">list</span>);</span><br><span class="line">        Iterator&lt;String&gt; iterator = <span class="keyword">list</span>.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.<span class="keyword">print</span>(iterator.next() + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"\n"</span>);</span><br><span class="line">        iterator = <span class="keyword">list</span>.iterator();</span><br><span class="line">        <span class="comment">//集合反转</span></span><br><span class="line">        Collections.reverse(<span class="keyword">list</span>);</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.<span class="keyword">print</span>(iterator.next() + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 结果：</span></span><br><span class="line"><span class="comment"> * A B K a b k</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * k b a K B A</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="9-Stream数据流-Collection接口"><a href="#9-Stream数据流-Collection接口" class="headerlink" title="9.Stream数据流:Collection接口"></a>9.Stream数据流:Collection接口</h3><p><a href>核心方法:取得Stream流 Stream<e> stream()</e></a></p><h5 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h5><ul><li style="list-style: none"><input type="checkbox"> forEach:集合输出</li><li style="list-style: none"><input type="checkbox"> filter:数据过滤</li><li style="list-style: none"><input type="checkbox"> 取得最大最小值：max/min<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStream01</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; <span class="built_in">list</span> = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Collections.addAll(<span class="built_in">list</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">//list.forEach(System.out::print);</span></span><br><span class="line">        Stream&lt;Integer&gt; stream = <span class="built_in">list</span>.stream();</span><br><span class="line">        <span class="comment">//偶数个数</span></span><br><span class="line">   <span class="comment">/*     System.out.println("count = " +</span></span><br><span class="line"><span class="comment">                stream.filter(e -&gt; e % 2 == 0).count());*/</span></span><br><span class="line">        <span class="comment">//求集合中的最大最小值</span></span><br><span class="line">        System.out.println(stream.max(Integer::compareTo)</span><br><span class="line">                .get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="Map-Reduce模型"><a href="#Map-Reduce模型" class="headerlink" title="Map/Reduce模型"></a>Map/Reduce模型</h5><ul><li style="list-style: none"><input type="checkbox"> map():前期数据的处理</li><li style="list-style: none"><input type="checkbox"> reduce():数据处理后的收集<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Goods</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer count;</span><br><span class="line">    <span class="keyword">private</span> Double price;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Goods</span><span class="params">(String name, Integer count, Double price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCount</span><span class="params">(Integer count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(Double price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMapAndReduce</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Goods&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="built_in">list</span>.add(<span class="keyword">new</span> Goods(<span class="string">"HUAWEI"</span>,<span class="number">500</span>,<span class="number">6000.00</span>));</span><br><span class="line">        <span class="built_in">list</span>.add(<span class="keyword">new</span> Goods(<span class="string">"APPLE"</span>,<span class="number">200</span>,<span class="number">7000.00</span>));</span><br><span class="line">        <span class="built_in">list</span>.add(<span class="keyword">new</span> Goods(<span class="string">"XIAOMI"</span>,<span class="number">600</span>,<span class="number">3000.00</span>));</span><br><span class="line">        <span class="built_in">list</span>.add(<span class="keyword">new</span> Goods(<span class="string">"OPPO"</span>,<span class="number">300</span>,<span class="number">3500.00</span>));</span><br><span class="line">        Double costs = <span class="built_in">list</span>.stream()</span><br><span class="line">                .<span class="built_in">map</span>(obj -&gt; obj.getCount()*obj.getPrice())</span><br><span class="line">                .reduce((sum,x) -&gt; sum+x).get();</span><br><span class="line">        System.out.println(costs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果：7250000.0</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaSE基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/2019/04/22/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/04/22/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="快速排序：基于分治思想-O-nlogn"><a href="#快速排序：基于分治思想-O-nlogn" class="headerlink" title="快速排序：基于分治思想 O(nlogn)"></a>快速排序：基于分治思想 O(nlogn)</h3><ul><li style="list-style: none"><input type="checkbox"> <strong>算法思路</strong>： 从待排序数组中任意选取一个元素[l…r],称为分区点，每当发现比基准值小的元素就放在基准值左边，大的放右边。每遍历一次基准值在最终位置。</li><li><p>[ ] <strong>原地排序：</strong> </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//核心算法</span></span><br><span class="line">    <span class="keyword">int</span> v = <span class="built_in">array</span>[l];<span class="comment">//基准值</span></span><br><span class="line">    <span class="keyword">int</span> j = l;<span class="comment">//比基准值小的范围[l+1,j]</span></span><br><span class="line">    <span class="keyword">int</span> i = l+<span class="number">1</span>;<span class="comment">//比基准值大的范围[j+1,i-1],i是当前索引</span></span><br><span class="line">    <span class="keyword">for</span> (;i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[i] &lt; v) &#123;</span><br><span class="line">            swap(<span class="built_in">array</span>,j+<span class="number">1</span>,i);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(<span class="built_in">array</span>,l,j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br></pre></td></tr></table></figure></li><li><p>[ ] <strong>问题</strong>：当待排序的集合近乎有序时，若选取的基准恰好为最大值，此时分层退化为O(n)，时间复杂度退化为O(n^2)——最坏情况</p></li><li>最好情况：每次区分点的选择恰好在中间位置，时间复杂度为O(nlogn)</li><li>空间复杂度：O(1)，原地排序算法</li><li>稳定性：不稳定算法，<a href>若基准值为最后一个元素,5 4 3 2 6 1 5</a></li><li><p>如何在O(n)时间内找到一个无序数组的第K大元素?</p></li><li><p>[ ] <strong>快排优化：</strong> </p></li></ul><ol><li>当待排序的集合近乎有序时，由于默认选择的第一个元素为基准，会导致基准值划分的两个子数组严重不均衡，此时分层下来的结果近乎于n层，此时快排退化为复杂度为O(n^2)排序算法</li></ol><ul><li style="list-style: none"><input type="checkbox" checked> <strong>解决</strong>：随机选取一个元素作为基准值，来降低每次都选到最小或最大值的概率<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> randomIndex = (<span class="keyword">int</span>)(Math.<span class="built_in">random</span>() * (r-l+<span class="number">1</span>) + l);</span><br><span class="line">swap(<span class="keyword">array</span>,l,randomIndex);</span><br><span class="line"><span class="keyword">int</span> v = <span class="keyword">array</span>[l];<span class="comment">//基准值</span></span><br><span class="line"><span class="keyword">int</span> j = l;<span class="comment">//比基准值小的范围[l+1,j]</span></span><br><span class="line"><span class="keyword">int</span> i = l+<span class="number">1</span>;<span class="comment">//比基准值大的范围[j+1,i-1],i是当前索引</span></span><br><span class="line"><span class="built_in">for</span> (;i &lt;= r; i++) &#123;</span><br><span class="line">    <span class="built_in">if</span> (<span class="keyword">array</span>[i] &lt; v) &#123;</span><br><span class="line">        swap(<span class="keyword">array</span>,j+<span class="number">1</span>,i);</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">swap(<span class="keyword">array</span>,l,j);</span><br><span class="line"><span class="built_in">return</span> j;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>当待排序数组含有大量重复元素时由于与基准值相等的元素个数过多，导致数组长度不均衡，此时分层下来的结果近乎n层，快排退化为O(n^2)</li></ol><ul><li><p>[x] <strong>二路快排</strong>：将大于和小于v的元素放在数组的两端,i索引不断向后扫描，当i的元素小于v时，i++;j索引不断向前扫描，当j的元素大于v时，j–;当i碰到一个&gt;=v的元素以及j碰到一个&lt;=v的元素，交换i与j的元素,i++,j–</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//核心算法</span></span><br><span class="line">        <span class="keyword">int</span> randomIndex = (<span class="keyword">int</span>)(Math.random() * (r-l+<span class="number">1</span>) + l);</span><br><span class="line">        swap(<span class="built_in">array</span>,l,randomIndex);</span><br><span class="line">        <span class="keyword">int</span> v = <span class="built_in">array</span>[l];</span><br><span class="line">        <span class="keyword">int</span> i = l + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = r;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt;= r &amp;&amp; <span class="built_in">array</span>[i] &lt; v) i++;<span class="comment">//注意：不仅要判断值的大小，还要判断i,j下标是否越界</span></span><br><span class="line">            <span class="keyword">while</span>(j &gt;= l + <span class="number">1</span> &amp;&amp; <span class="built_in">array</span>[j] &gt; v) j--;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; j) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(<span class="built_in">array</span>,i,j);</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">       swap(<span class="built_in">array</span>,l,j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br></pre></td></tr></table></figure></li><li><p>[x] <strong>三路快排</strong>：</p></li><li style="list-style: none"><input type="checkbox" checked> <strong>归并排序优化</strong>：</li><li>当元素个数比较小的时候，直接调用直接插入排序</li><li>当左边数组最大元素都小于右边数组最小元素，说明整个数组有序</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DataStructures </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 三大类</title>
      <link href="/2019/04/22/Java-%E4%B8%89%E5%A4%A7%E7%B1%BB/"/>
      <url>/2019/04/22/Java-%E4%B8%89%E5%A4%A7%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><blockquote><p>注：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">int</span> data = <span class="number">10</span>;<span class="comment">//堆</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> data2 = <span class="number">20</span>;<span class="comment">//方法区</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> data3 = <span class="number">30</span>;<span class="comment">//方法区</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> data4 = <span class="number">40</span>;<span class="comment">//堆</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String </span><span class="keyword">str </span>= <span class="string">"helloworld"</span><span class="comment">;//直接赋值放在常量池</span></span><br><span class="line"><span class="keyword">Strring </span><span class="keyword">str2 </span>= <span class="string">"hello"</span> + <span class="string">"world"</span><span class="comment">;//常量池</span></span><br><span class="line"><span class="symbol">System.out.print</span>(<span class="keyword">str </span>== <span class="keyword">str2);//true</span></span><br><span class="line"><span class="keyword">Strring </span><span class="keyword">str3 </span>= <span class="string">"hello"</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">String </span><span class="keyword">str4 </span>= <span class="keyword">str3 </span>+ <span class="string">"word"</span><span class="comment">;//str3是一个变量</span></span><br><span class="line"><span class="symbol">System.out.prinntln</span>(<span class="keyword">str </span>== <span class="keyword">str4);//false</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">String </span><span class="keyword">str5 </span>= new <span class="keyword">String("terry").intern();//intern()手动入池方法，如果常量池已经有，则直接返回常量池中的地址，下式仍然相等</span></span><br><span class="line"><span class="keyword">String </span><span class="keyword">str6 </span>= <span class="string">"terry"</span><span class="comment">;</span></span><br><span class="line"><span class="symbol">System.out.println</span>(<span class="keyword">str5 </span>== <span class="keyword">str6);//true</span></span><br></pre></td></tr></table></figure><p>如何判断常量池是否存在字符常量</p><ul><li style="list-style: none"><input type="checkbox" checked> <strong>String StringBuffer 和StringBuilder的区别和 联系：</strong></li><li>StringBuffer –&gt; synchronized，StringBuffer多线程情况下使用，sychronized线程安全关键字，StringBuilder 、String都没有，线程不安全</li><li>StringBuffer、StringBuilder的append（）方法不会产生垃圾空间，追加后，地址不会改变；</li><li>String的拼接底层会优化为StringBuilder append进行拼接，结果会调用StringBuilder的toString（）,但在循环中拼接时，优先使用StringBuilder；</li><li style="list-style: none"><input type="checkbox"> StringIndexOutOfBoundsException </li><li style="list-style: none"><input type="checkbox"> Character.isDigit() 判断一个字符是否为数字</li><li style="list-style: none"><input type="checkbox"> 基类可以引用派生类对象（类，接口）<h3 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h3><h5 id="装箱（装包）：把一个简单类型包装为一个对象"><a href="#装箱（装包）：把一个简单类型包装为一个对象" class="headerlink" title="装箱（装包）：把一个简单类型包装为一个对象"></a>装箱（装包）：把一个简单类型包装为一个对象</h5></li><li style="list-style: none"><input type="checkbox"> <a href>Integer a = 10;//自动装箱:Integer.valueOf()</a></li><li style="list-style: none"><input type="checkbox"> <a href>Integer b = new Integer(20;//显示装箱（没有调用valueOf）)</a><h5 id="拆箱：把包装类拆分为简单类型"><a href="#拆箱：把包装类拆分为简单类型" class="headerlink" title="拆箱：把包装类拆分为简单类型"></a>拆箱：把包装类拆分为简单类型</h5></li><li style="list-style: none"><input type="checkbox"> <a href>int i = a;//自动拆箱：Integer.intValue()</a></li><li style="list-style: none"><input type="checkbox"> <a href>double d = a.doubleValue();</a><blockquote><p><strong>valueOf判断实例：(具体原因看valueOf源代码)</strong></p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Integer</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">Integer</span> b = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">System</span>.out.println(a == b);<span class="comment">//true</span></span><br><span class="line"><span class="keyword">Integer</span> a = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">Integer</span> b = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">System</span>.out.println(a == b);<span class="comment">//false</span></span><br><span class="line"><span class="comment">//原因valueOf在-128~127之间直接引用，否则new一个新对象；</span></span><br></pre></td></tr></table></figure></blockquote></li></ul><h3 id="单例："><a href="#单例：" class="headerlink" title="单例："></a>单例：</h3><ul><li style="list-style: none"><input type="checkbox"> 请使用吧静态内部类实现一个单例模式：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySingleton</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Single</span> &#123;</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> MySingleton mySingleton = <span class="keyword">new</span> MySingleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Single.mySingleton;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaSE基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何不翻墙访问谷歌</title>
      <link href="/2019/04/20/%E5%A6%82%E4%BD%95%E4%B8%8D%E7%BF%BB%E5%A2%99%E8%AE%BF%E9%97%AE%E8%B0%B7%E6%AD%8C/"/>
      <url>/2019/04/20/%E5%A6%82%E4%BD%95%E4%B8%8D%E7%BF%BB%E5%A2%99%E8%AE%BF%E9%97%AE%E8%B0%B7%E6%AD%8C/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp; 我们都知道谷歌浏览器被全球公认为全球最大的搜索引擎公司，而且不像百度，360等前几条全是广告。因此很方便我们进行资料查询。而现在是不允许访问谷歌的，进行翻墙的话，要么网速不稳定，要么得花钱。<strong>那如何访问呢？</strong></p><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><ul><li>首先下载<strong>360极速浏览器</strong>，它基于<a href="https://baike.baidu.com/item/Chromium/529755" target="_blank" rel="noopener">Chromium</a>开源项目，具有闪电般的浏览速度、完备的安全特性及海量丰富的实用工具扩展。以前其自带谷歌访问助手，现在在插件中心收不到了。</li><li>下载Google访问助手，<a href="https://pan.baidu.com/s/1DXSmRyj1WJO6UW7xfTtSaQ" target="_blank" rel="noopener">点这里</a>,提取码<strong>e50z </strong>；</li><li>下载好后，打开360急速浏览器，再直接运行插件即可。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客</title>
      <link href="/2019/04/19/%E4%B8%8A%E4%BC%A0/"/>
      <url>/2019/04/19/%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="基于Hexo搭建个人博客"><a href="#基于Hexo搭建个人博客" class="headerlink" title="基于Hexo搭建个人博客"></a>基于Hexo搭建个人博客</h3><h4 id="创建原因："><a href="#创建原因：" class="headerlink" title="创建原因："></a>创建原因：</h4><p>&nbsp; &nbsp; 以前我写的博客都上传在<a href="https://github.com/beerNewbie" target="_blank" rel="noopener">github</a>上，但是每次想查询、复习的时候都不是十分方便。至于CSDN就是广告让人受不了。并且看见 别人那简洁清新的博客，心里很是痒痒。便自己动手搭建一个。</p><h4 id="历程"><a href="#历程" class="headerlink" title="历程"></a>历程</h4><p>&nbsp; &nbsp; 通过网上的一些视频资料，搭建起来不是很难。但要配置出自己喜欢的主题还是很费精力的，我前前后后下了几个主题，要么修改起来太过复杂，要么界面不好看。后来还是老老实实的选择很适合新手的<a href="https://http://theme-next.iissnan.com/" target="_blank" rel="noopener">hexo-theme-next</a>这款主题。很简洁清新。</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> others </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
